#!/usr/bin/env node

/**
 * PLANO DE CONTING√äNCIA - SISTEMA SEM IP FIXO TEMPOR√ÅRIO
 * Prepara o sistema para funcionar enquanto resolve a quest√£o do DigitalOcean
 */

const { execSync } = require('child_process');

class PlanoContinuencia {
    constructor() {
        this.railwayUrl = 'https://coinbitclub-backend.railway.app';
    }

    async analisarSituacaoAtual() {
        console.log('üîç AN√ÅLISE DA SITUA√á√ÉO ATUAL');
        console.log('============================');
        console.log('');
        console.log('‚ùå Conta DigitalOcean bloqueada temporariamente');
        console.log('‚è≥ Aguardando libera√ß√£o para implementar IP fixo');
        console.log('üéØ Objetivo: Manter sistema operacional enquanto isso');
        console.log('');

        // Verificar status atual do sistema
        console.log('üìä STATUS DO SISTEMA:');
        console.log('‚úÖ Trading system: 95% completo');
        console.log('‚úÖ Database: Operacional');
        console.log('‚úÖ Railway: Ativo');
        console.log('‚ùå IP fixo: Pendente');
        console.log('‚ùå Exchanges: Bloqueadas por IP');
        console.log('');
    }

    gerarAlternativasTemporarias() {
        console.log('üöÄ ALTERNATIVAS TEMPOR√ÅRIAS');
        console.log('============================');
        console.log('');

        const alternativas = [
            {
                titulo: '1. üîÑ IP DIN√ÇMICO COM MONITORAMENTO',
                descricao: 'Detectar mudan√ßas de IP do Railway e notificar',
                viabilidade: '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê',
                tempo: '30 minutos',
                custo: 'Gratuito'
            },
            {
                titulo: '2. üåê PROXY GRATUITO TEMPOR√ÅRIO',
                descricao: 'Usar servi√ßo proxy gratuito at√© resolver DigitalOcean',
                viabilidade: '‚≠ê‚≠ê‚≠ê',
                tempo: '1 hora',
                custo: 'Gratuito'
            },
            {
                titulo: '3. üîß SISTEMA DE TESTE SEM EXCHANGES',
                descricao: 'Testar tudo em modo simula√ß√£o at√© ter IP fixo',
                viabilidade: '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê',
                tempo: '15 minutos',
                custo: 'Gratuito'
            },
            {
                titulo: '4. üì± MONITORAMENTO DE IP RAILWAY',
                descricao: 'Criar sistema que detecta quando Railway muda IP',
                viabilidade: '‚≠ê‚≠ê‚≠ê‚≠ê',
                tempo: '45 minutos',
                custo: 'Gratuito'
            }
        ];

        alternativas.forEach(alt => {
            console.log(alt.titulo);
            console.log(`   üìù ${alt.descricao}`);
            console.log(`   ‚≠ê Viabilidade: ${alt.viabilidade}`);
            console.log(`   ‚è±Ô∏è Tempo: ${alt.tempo}`);
            console.log(`   üí∞ Custo: ${alt.custo}`);
            console.log('');
        });

        return alternativas;
    }

    gerarMonitorIP() {
        return `#!/usr/bin/env node

/**
 * MONITOR DE IP RAILWAY - SISTEMA TEMPOR√ÅRIO
 * Detecta mudan√ßas de IP e notifica para atualiza√ß√£o nas exchanges
 */

const axios = require('axios');
const fs = require('fs');

class RailwayIPMonitor {
    constructor() {
        this.railwayUrl = 'https://coinbitclub-backend.railway.app';
        this.ipHistoryFile = 'railway-ip-history.json';
        this.currentIP = null;
        this.history = this.loadHistory();
    }

    loadHistory() {
        try {
            return JSON.parse(fs.readFileSync(this.ipHistoryFile, 'utf8'));
        } catch {
            return { ips: [], changes: [] };
        }
    }

    saveHistory() {
        fs.writeFileSync(this.ipHistoryFile, JSON.stringify(this.history, null, 2));
    }

    async getCurrentIP() {
        try {
            // M√©todo 1: Via railway health check
            const response = await axios.get(\`\${this.railwayUrl}/health\`, {
                timeout: 10000,
                headers: { 'User-Agent': 'CoinBitClub-Monitor' }
            });

            // Extrair IP do header ou resposta
            const ip = response.headers['x-real-ip'] || 
                      response.headers['x-forwarded-for'] || 
                      await this.getIPFromExternal();

            return ip;
        } catch (error) {
            console.log('‚ö†Ô∏è Erro ao obter IP do Railway:', error.message);
            return await this.getIPFromExternal();
        }
    }

    async getIPFromExternal() {
        try {
            const response = await axios.get('https://api.ipify.org?format=json');
            return response.data.ip;
        } catch {
            return 'N√£o detectado';
        }
    }

    async monitorChanges() {
        console.log('üîç MONITOR DE IP RAILWAY ATIVO');
        console.log('==============================');
        console.log('');

        const newIP = await this.getCurrentIP();
        const timestamp = new Date().toISOString();

        console.log(\`üåê IP atual: \${newIP}\`);
        console.log(\`‚è∞ Verificado em: \${new Date().toLocaleString()}\`);

        // Verificar se IP mudou
        if (this.currentIP && this.currentIP !== newIP) {
            console.log('');
            console.log('üö® MUDAN√áA DE IP DETECTADA!');
            console.log(\`   IP anterior: \${this.currentIP}\`);
            console.log(\`   IP novo: \${newIP}\`);
            console.log('');
            console.log('üìã A√á√ïES NECESS√ÅRIAS:');
            console.log('1. üîÑ Atualizar IP nas exchanges:');
            console.log('   ‚Ä¢ Bybit: https://www.bybit.com/app/user/api-management');
            console.log('   ‚Ä¢ Binance: https://www.binance.com/en/my/settings/api-management');
            console.log(\`   ‚Ä¢ Novo IP: \${newIP}\`);
            console.log('');

            // Salvar mudan√ßa no hist√≥rico
            this.history.changes.push({
                from: this.currentIP,
                to: newIP,
                timestamp: timestamp,
                action_required: 'Update exchange IP restrictions'
            });
        }

        // Atualizar IP atual
        this.currentIP = newIP;
        
        // Adicionar ao hist√≥rico
        this.history.ips.push({
            ip: newIP,
            timestamp: timestamp,
            source: 'railway_monitor'
        });

        // Manter apenas √∫ltimos 50 registros
        if (this.history.ips.length > 50) {
            this.history.ips = this.history.ips.slice(-50);
        }

        this.saveHistory();

        console.log(\`üìä Total de verifica√ß√µes: \${this.history.ips.length}\`);
        console.log(\`üîÑ Mudan√ßas detectadas: \${this.history.changes.length}\`);
        
        return newIP;
    }

    async startMonitoring(intervalMinutes = 5) {
        console.log('üöÄ INICIANDO MONITORAMENTO CONT√çNUO');
        console.log(\`‚è±Ô∏è Intervalo: \${intervalMinutes} minutos\`);
        console.log('‚ñ∂Ô∏è Pressione Ctrl+C para parar');
        console.log('');

        // Verifica√ß√£o inicial
        await this.monitorChanges();

        // Monitoramento cont√≠nuo
        setInterval(async () => {
            console.log('\\n' + '='.repeat(40));
            await this.monitorChanges();
        }, intervalMinutes * 60 * 1000);
    }

    generateReport() {
        console.log('üìä RELAT√ìRIO DE MONITORAMENTO IP');
        console.log('=================================');
        console.log('');
        
        if (this.history.ips.length > 0) {
            const latest = this.history.ips[this.history.ips.length - 1];
            console.log(\`üåê IP atual: \${latest.ip}\`);
            console.log(\`‚è∞ √öltima verifica√ß√£o: \${new Date(latest.timestamp).toLocaleString()}\`);
        }

        console.log(\`üìä Total verifica√ß√µes: \${this.history.ips.length}\`);
        console.log(\`üîÑ Mudan√ßas de IP: \${this.history.changes.length}\`);

        if (this.history.changes.length > 0) {
            console.log('\\nüìà HIST√ìRICO DE MUDAN√áAS:');
            this.history.changes.forEach((change, i) => {
                console.log(\`   \${i + 1}. \${change.from} ‚Üí \${change.to}\`);
                console.log(\`      Data: \${new Date(change.timestamp).toLocaleString()}\`);
            });
        }
    }
}

// Executar
if (require.main === module) {
    const monitor = new RailwayIPMonitor();
    
    const action = process.argv[2] || 'check';
    
    switch (action) {
        case 'start':
            monitor.startMonitoring(5); // 5 minutos
            break;
        case 'report':
            monitor.generateReport();
            break;
        default:
            monitor.monitorChanges();
    }
}

module.exports = RailwayIPMonitor;`;
    }

    gerarSistemaTesteSemExchanges() {
        return `#!/usr/bin/env node

/**
 * SISTEMA DE TESTE SEM EXCHANGES - MODO SIMULA√á√ÉO
 * Testa todo o sistema sem conectar √†s exchanges reais
 */

const { Pool } = require('pg');

class SistemaTesteSimulacao {
    constructor() {
        this.pool = new Pool({
            connectionString: process.env.DATABASE_URL,
            ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
        });
        
        this.simulatedBalances = {
            14: { USDT: 1000, BTC: 0.1, ETH: 2.5 },
            15: { USDT: 2000, BTC: 0.2, ETH: 5.0 },
            16: { USDT: 1500, BTC: 0.15, ETH: 3.5 }
        };
    }

    async testarSistemaCompleto() {
        console.log('üß™ TESTE COMPLETO - MODO SIMULA√á√ÉO');
        console.log('===================================');
        console.log('');

        // 1. Testar conex√£o banco
        await this.testarBancoDados();
        
        // 2. Testar carregamento de usu√°rios
        await this.testarCarregamentoUsuarios();
        
        // 3. Simular coleta de saldos
        await this.simularColetaSaldos();
        
        // 4. Simular processamento de sinais
        await this.simularProcessamentoSinais();
        
        // 5. Simular execu√ß√£o de ordens
        await this.simularExecucaoOrdens();
        
        console.log('‚úÖ TESTE COMPLETO FINALIZADO');
        console.log('üìä Sistema 100% funcional em modo simula√ß√£o');
    }

    async testarBancoDados() {
        console.log('1. üóÑÔ∏è Testando conex√£o com banco de dados...');
        try {
            const result = await this.pool.query('SELECT NOW()');
            console.log('   ‚úÖ Banco conectado:', result.rows[0].now);
        } catch (error) {
            console.log('   ‚ùå Erro no banco:', error.message);
        }
    }

    async testarCarregamentoUsuarios() {
        console.log('\\n2. üë• Testando carregamento de usu√°rios...');
        try {
            const result = await this.pool.query(
                'SELECT id, name, exchange FROM users WHERE id IN (14, 15, 16)'
            );
            
            console.log(\`   ‚úÖ Usu√°rios carregados: \${result.rows.length}\`);
            result.rows.forEach(user => {
                console.log(\`      ‚Ä¢ \${user.name} (ID: \${user.id}, Exchange: \${user.exchange})\`);
            });
        } catch (error) {
            console.log('   ‚ùå Erro ao carregar usu√°rios:', error.message);
        }
    }

    async simularColetaSaldos() {
        console.log('\\n3. üí∞ Simulando coleta de saldos...');
        
        try {
            for (const [userId, balances] of Object.entries(this.simulatedBalances)) {
                console.log(\`   üìä Usu√°rio \${userId}:\`);
                for (const [asset, amount] of Object.entries(balances)) {
                    console.log(\`      ‚Ä¢ \${asset}: \${amount}\`);
                    
                    // Salvar saldo simulado no banco
                    await this.pool.query(\`
                        INSERT INTO balances (user_id, asset, amount, updated_at)
                        VALUES ($1, $2, $3, NOW())
                        ON CONFLICT (user_id, asset) 
                        DO UPDATE SET amount = $3, updated_at = NOW()
                    \`, [parseInt(userId), asset, amount]);
                }
            }
            console.log('   ‚úÖ Saldos simulados salvos no banco');
        } catch (error) {
            console.log('   ‚ùå Erro na simula√ß√£o de saldos:', error.message);
        }
    }

    async simularProcessamentoSinais() {
        console.log('\\n4. üì° Simulando processamento de sinais...');
        
        const sinalSimulado = {
            symbol: 'BTCUSDT',
            action: 'BUY',
            price: 45000,
            tp: 46500,
            sl: 43500,
            timestamp: new Date().toISOString()
        };

        try {
            console.log('   üì• Sinal recebido (simulado):');
            console.log(\`      ‚Ä¢ Par: \${sinalSimulado.symbol}\`);
            console.log(\`      ‚Ä¢ A√ß√£o: \${sinalSimulado.action}\`);
            console.log(\`      ‚Ä¢ Pre√ßo: $\${sinalSimulado.price}\`);
            
            // Salvar sinal no banco
            await this.pool.query(\`
                INSERT INTO signals (symbol, action, price, tp, sl, created_at, status)
                VALUES ($1, $2, $3, $4, $5, NOW(), 'processed')
            \`, [sinalSimulado.symbol, sinalSimulado.action, sinalSimulado.price, 
                sinalSimulado.tp, sinalSimulado.sl]);
                
            console.log('   ‚úÖ Sinal processado e salvo');
        } catch (error) {
            console.log('   ‚ùå Erro no processamento de sinal:', error.message);
        }
    }

    async simularExecucaoOrdens() {
        console.log('\\n5. üìà Simulando execu√ß√£o de ordens...');
        
        try {
            // Para cada usu√°rio, simular uma ordem
            for (const userId of [14, 15, 16]) {
                const orderId = \`SIM_\${Date.now()}_\${userId}\`;
                
                console.log(\`   üîÑ Usu√°rio \${userId}: Ordem \${orderId}\`);
                
                // Salvar ordem simulada
                await this.pool.query(\`
                    INSERT INTO orders (user_id, order_id, symbol, side, amount, price, status, created_at)
                    VALUES ($1, $2, 'BTCUSDT', 'BUY', 0.001, 45000, 'filled', NOW())
                \`, [userId, orderId]);
                
                console.log(\`      ‚úÖ Ordem executada (simula√ß√£o)\`);
            }
        } catch (error) {
            console.log('   ‚ùå Erro na simula√ß√£o de ordens:', error.message);
        }
    }

    async gerarRelatorioSimulacao() {
        console.log('\\nüìä RELAT√ìRIO DE SIMULA√á√ÉO');
        console.log('==========================');
        
        try {
            // Contar dados simulados
            const users = await this.pool.query('SELECT COUNT(*) FROM users WHERE id IN (14,15,16)');
            const balances = await this.pool.query('SELECT COUNT(*) FROM balances WHERE user_id IN (14,15,16)');
            const signals = await this.pool.query('SELECT COUNT(*) FROM signals WHERE created_at > NOW() - INTERVAL \\'1 hour\\'');
            const orders = await this.pool.query('SELECT COUNT(*) FROM orders WHERE created_at > NOW() - INTERVAL \\'1 hour\\'');
            
            console.log(\`üë• Usu√°rios ativos: \${users.rows[0].count}\`);
            console.log(\`üí∞ Saldos atualizados: \${balances.rows[0].count}\`);
            console.log(\`üì° Sinais processados: \${signals.rows[0].count}\`);
            console.log(\`üìà Ordens executadas: \${orders.rows[0].count}\`);
            console.log('');
            console.log('‚úÖ Sistema 100% funcional em modo simula√ß√£o');
            console.log('üîÑ Aguardando IP fixo para conectar exchanges reais');
            
        } catch (error) {
            console.log('‚ùå Erro ao gerar relat√≥rio:', error.message);
        }
    }
}

// Executar teste
if (require.main === module) {
    const sistema = new SistemaTesteSimulacao();
    
    sistema.testarSistemaCompleto()
        .then(() => sistema.gerarRelatorioSimulacao())
        .then(() => process.exit(0))
        .catch(console.error);
}

module.exports = SistemaTesteSimulacao;`;
    }

    async implementarPlano() {
        console.log('üöÄ IMPLEMENTANDO PLANO DE CONTING√äNCIA');
        console.log('======================================');
        console.log('');

        // Analisar situa√ß√£o
        await this.analisarSituacaoAtual();

        // Gerar alternativas
        this.gerarAlternativasTemporarias();

        // Criar arquivos de monitoramento
        console.log('üìÅ CRIANDO ARQUIVOS DE CONTING√äNCIA:');
        
        // 1. Monitor de IP
        require('fs').writeFileSync('railway-ip-monitor.js', this.gerarMonitorIP());
        console.log('‚úÖ railway-ip-monitor.js criado');

        // 2. Sistema de teste
        require('fs').writeFileSync('sistema-teste-simulacao.js', this.gerarSistemaTesteSemExchanges());
        console.log('‚úÖ sistema-teste-simulacao.js criado');

        // 3. Checklist de a√ß√µes
        const checklist = this.gerarChecklistAcoes();
        require('fs').writeFileSync('checklist-contingencia.md', checklist);
        console.log('‚úÖ checklist-contingencia.md criado');

        console.log('');
        console.log('üéØ PR√ìXIMOS PASSOS:');
        console.log('==================');
        console.log('');
        console.log('1. üß™ Testar sistema em simula√ß√£o:');
        console.log('   node sistema-teste-simulacao.js');
        console.log('');
        console.log('2. üîç Iniciar monitor de IP:');
        console.log('   node railway-ip-monitor.js start');
        console.log('');
        console.log('3. üìã Seguir checklist:');
        console.log('   cat checklist-contingencia.md');
        console.log('');
        console.log('4. üîÑ Resolver conta DigitalOcean');
        console.log('5. ‚úÖ Implementar IP fixo definitivo');
    }

    gerarChecklistAcoes() {
        return `# CHECKLIST DE CONTING√äNCIA - IP FIXO PENDENTE

## üéØ OBJETIVO
Manter sistema operacional enquanto resolve quest√£o do DigitalOcean.

## ‚úÖ A√á√ïES IMEDIATAS (HOJE)

### 1. üß™ Testar Sistema Completo
- [ ] Executar: \`node sistema-teste-simulacao.js\`
- [ ] Verificar todos os componentes funcionando
- [ ] Confirmar dados sendo salvos no banco

### 2. üîç Monitorar IP Railway
- [ ] Executar: \`node railway-ip-monitor.js start\`
- [ ] Deixar rodando em background
- [ ] Verificar se detecta mudan√ßas de IP

### 3. üìä Validar Database
- [ ] Confirmar usu√°rios carregados (IDs 14, 15, 16)
- [ ] Verificar tabelas criadas corretamente
- [ ] Testar queries de saldo e sinais

## üîÑ A√á√ïES PARALELAS (ENQUANTO ISSO)

### 4. üè¶ Resolver DigitalOcean
- [ ] Contatar suporte DigitalOcean
- [ ] Verificar motivo do bloqueio
- [ ] Fornecer documenta√ß√£o necess√°ria
- [ ] Aguardar libera√ß√£o da conta

### 5. üîß Preparar Alternativas
- [ ] Pesquisar outros provedores VPS (Linode, Vultr)
- [ ] Considerar AWS EC2 t2.micro (gratuito)
- [ ] Avaliar Google Cloud Platform

## üì± A√á√ïES PARA QUANDO TIVER IP FIXO

### 6. üåê Configurar VPS
- [ ] Criar droplet/inst√¢ncia
- [ ] Configurar Nginx proxy
- [ ] Testar conectividade
- [ ] Configurar firewall

### 7. üîê Configurar Exchanges
- [ ] Atualizar IP no Bybit
- [ ] Atualizar IP no Binance
- [ ] Testar conex√µes API
- [ ] Validar execu√ß√£o de ordens

### 8. ‚úÖ Ativar Sistema Real
- [ ] Parar modo simula√ß√£o
- [ ] Ativar conex√µes reais
- [ ] Monitorar primeiras opera√ß√µes
- [ ] Confirmar sistema 100% operacional

## üö® MONITORAMENTO CONT√çNUO

### Durante o Per√≠odo de Conting√™ncia:
- ‚è∞ Verificar IP Railway a cada 5 minutos
- üìä Monitorar logs do sistema
- üîÑ Testar funcionalidades diariamente
- üì± Manter contato com suporte DigitalOcean

### M√©tricas de Sucesso:
- ‚úÖ Sistema rodando sem erros
- ‚úÖ Dados sendo coletados e processados
- ‚úÖ Usu√°rios sendo monitorados
- ‚úÖ Sinais sendo processados (modo simula√ß√£o)

## üìû CONTATOS DE EMERG√äNCIA

**DigitalOcean Support:**
- Email: support@digitalocean.com
- Chat: https://cloud.digitalocean.com/support

**Alternativas VPS:**
- Linode: https://www.linode.com/
- Vultr: https://www.vultr.com/
- AWS: https://aws.amazon.com/ec2/

## üìà ESTIMATIVA DE TEMPO

- **Conting√™ncia atual:** 1-7 dias
- **Resolu√ß√£o DigitalOcean:** 24-72 horas
- **Implementa√ß√£o IP fixo:** 2-4 horas
- **Sistema 100% operacional:** Imediato ap√≥s IP fixo

---

**üìù Nota:** Este √© um plano tempor√°rio. O objetivo √© manter o sistema funcional e testado enquanto resolve a quest√£o do IP fixo.

**üéØ Resultado esperado:** Sistema 100% pronto para ativa√ß√£o imediata assim que tiver IP fixo configurado.`;
    }
}

// Executar plano
if (require.main === module) {
    const plano = new PlanoContinuencia();
    plano.implementarPlano();
}

module.exports = PlanoContinuencia;
