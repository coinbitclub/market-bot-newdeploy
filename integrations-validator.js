#!/usr/bin/env node

/**
 * üîß COINBITCLUB INTEGRATIONS VALIDATOR & FIXER
 * 
 * Valida e corrige integra√ß√µes cr√≠ticas em ambiente real:
 * - OpenAI para IA de an√°lise e decis√µes
 * - Stripe para pagamentos e assinaturas
 * - Twilio para SMS e notifica√ß√µes
 * 
 * Executa testes reais e corrige configura√ß√µes automaticamente
 */

require('dotenv').config();
const { Pool } = require('pg');

class IntegrationsValidator {
    constructor() {
        this.pool = new Pool({
            connectionString: process.env.DATABASE_URL,
            ssl: { rejectUnauthorized: false }
        });

        this.results = {
            openai: { status: 'pending', tests: [], errors: [] },
            stripe: { status: 'pending', products: [], webhooks: [], errors: [] },
            twilio: { status: 'pending', services: [], errors: [] }
        };

        console.log('üîß INTEGRATIONS VALIDATOR INICIADO');
        console.log('====================================');
    }

    async validateAllIntegrations() {
        try {
            console.log('\nüöÄ VALIDANDO TODAS AS INTEGRA√á√ïES...\n');

            // 1. Validar OpenAI com testes reais
            await this.validateOpenAIIntegration();

            // 2. Validar Stripe com produtos e webhooks reais
            await this.validateStripeIntegration();

            // 3. Validar Twilio com SMS real
            await this.validateTwilioIntegration();

            // 4. Gerar relat√≥rio final
            await this.generateIntegrationsReport();

        } catch (error) {
            console.error('‚ùå ERRO CR√çTICO:', error);
            process.exit(1);
        }
    }

    async validateOpenAIIntegration() {
        console.log('ü§ñ VALIDANDO INTEGRA√á√ÉO OPENAI...');

        if (!process.env.OPENAI_API_KEY) {
            this.results.openai.errors.push('API Key n√£o configurada');
            this.results.openai.status = 'error';
            return;
        }

        try {
            const { OpenAI } = require('openai');
            const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

            // Teste 1: Conex√£o b√°sica
            console.log('üß™ Teste 1: Conex√£o b√°sica...');
            const basicTest = await openai.chat.completions.create({
                model: "gpt-3.5-turbo",
                messages: [{ role: "user", content: "Hello" }],
                max_tokens: 5
            });

            this.results.openai.tests.push({
                name: 'Conex√£o b√°sica',
                status: 'success',
                response: basicTest.choices[0].message.content
            });
            console.log('‚úÖ Conex√£o b√°sica funcionando');

            // Teste 2: An√°lise de mercado (caso de uso real)
            console.log('üß™ Teste 2: An√°lise de mercado...');
            const marketAnalysis = await openai.chat.completions.create({
                model: "gpt-4",
                messages: [{
                    role: "system",
                    content: "Voc√™ √© um analista expert em criptomoedas. Analise os dados fornecidos e d√™ uma recomenda√ß√£o clara."
                }, {
                    role: "user", 
                    content: "Bitcoin est√° em $45,000, RSI 65, MACD bullish, volume acima da m√©dia. Fear & Greed Index: 60. Qual sua an√°lise?"
                }],
                max_tokens: 200
            });

            this.results.openai.tests.push({
                name: 'An√°lise de mercado',
                status: 'success',
                response: marketAnalysis.choices[0].message.content.substring(0, 100) + '...'
            });
            console.log('‚úÖ An√°lise de mercado funcionando');

            // Teste 3: Processamento de sinais (integra√ß√£o com trading)
            console.log('üß™ Teste 3: Processamento de sinais...');
            const signalProcessing = await openai.chat.completions.create({
                model: "gpt-3.5-turbo",
                messages: [{
                    role: "system",
                    content: "Analise o sinal de trading e retorne apenas: APPROVE, REJECT ou WAIT_CONFIRMATION"
                }, {
                    role: "user",
                    content: "SINAL_LONG BTCUSDT $45000 RSI:65 MACD:bullish Volume:high FearGreed:60"
                }],
                max_tokens: 10
            });

            this.results.openai.tests.push({
                name: 'Processamento de sinais',
                status: 'success',
                response: signalProcessing.choices[0].message.content.trim()
            });
            console.log('‚úÖ Processamento de sinais funcionando');

            // Teste 4: Cria√ß√£o de fun√ß√£o de monitoramento IA
            await this.createAIMonitoringFunction(openai);

            this.results.openai.status = 'success';
            console.log('‚úÖ OpenAI completamente integrado e funcional\n');

        } catch (error) {
            console.error('‚ùå Erro OpenAI:', error.message);
            this.results.openai.status = 'error';
            this.results.openai.errors.push(error.message);
        }
    }

    async createAIMonitoringFunction(openai) {
        console.log('üß™ Teste 4: Criando fun√ß√£o de monitoramento IA...');

        const aiMonitoringCode = `
const { OpenAI } = require('openai');

class CoinbitClubAIMonitor {
    constructor() {
        this.openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
        this.lastAnalysis = null;
        this.analysisHistory = [];
    }

    async analyzeMarketSignal(signalData) {
        try {
            const prompt = \`
Analise este sinal de trading:
- A√ß√£o: \${signalData.action}
- Par: \${signalData.ticker}
- Pre√ßo: \${signalData.price}
- RSI: \${signalData.rsi || 'N/A'}
- Fear & Greed: \${signalData.fearGreed || 'N/A'}
- Volume: \${signalData.volume || 'N/A'}

Responda apenas com: APPROVE, REJECT, ou WAIT_CONFIRMATION
\`;

            const response = await this.openai.chat.completions.create({
                model: "gpt-3.5-turbo",
                messages: [
                    { role: "system", content: "Voc√™ √© um analista de trading expert. Seja conciso." },
                    { role: "user", content: prompt }
                ],
                max_tokens: 10
            });

            const decision = response.choices[0].message.content.trim();
            
            this.lastAnalysis = {
                signal: signalData,
                decision: decision,
                timestamp: new Date(),
                confidence: this.calculateConfidence(signalData)
            };

            this.analysisHistory.push(this.lastAnalysis);
            
            return {
                decision: decision,
                confidence: this.lastAnalysis.confidence,
                reasoning: "AI analysis based on market indicators"
            };

        } catch (error) {
            console.error('‚ùå Erro na an√°lise IA:', error);
            return { decision: 'WAIT_CONFIRMATION', confidence: 0, reasoning: 'AI analysis failed' };
        }
    }

    calculateConfidence(signalData) {
        let confidence = 50; // Base confidence
        
        if (signalData.rsi) {
            if (signalData.rsi > 30 && signalData.rsi < 70) confidence += 10;
            if (signalData.rsi > 20 && signalData.rsi < 80) confidence += 5;
        }
        
        if (signalData.fearGreed) {
            if (signalData.fearGreed > 25 && signalData.fearGreed < 75) confidence += 10;
        }
        
        return Math.min(confidence, 95); // Max 95% confidence
    }

    async generateDailyReport() {
        const recentAnalyses = this.analysisHistory.slice(-10);
        const approvals = recentAnalyses.filter(a => a.decision === 'APPROVE').length;
        const rejections = recentAnalyses.filter(a => a.decision === 'REJECT').length;
        
        const prompt = \`
Gere um relat√≥rio baseado nas an√°lises recentes:
- Total de an√°lises: \${recentAnalyses.length}
- Aprova√ß√µes: \${approvals}
- Rejei√ß√µes: \${rejections}
- Per√≠odo: √∫ltimas 24 horas

Forne√ßa insights sobre performance e tend√™ncias de mercado.
\`;

        try {
            const response = await this.openai.chat.completions.create({
                model: "gpt-4",
                messages: [
                    { role: "system", content: "Gere um relat√≥rio profissional de trading." },
                    { role: "user", content: prompt }
                ],
                max_tokens: 500
            });

            return response.choices[0].message.content;
        } catch (error) {
            return "Erro ao gerar relat√≥rio: " + error.message;
        }
    }
}

module.exports = CoinbitClubAIMonitor;
`;

        // Salvar fun√ß√£o de monitoramento IA
        require('fs').writeFileSync('./ai-monitoring-integration.js', aiMonitoringCode);
        console.log('‚úÖ Fun√ß√£o de monitoramento IA criada: ai-monitoring-integration.js');

        // Testar a fun√ß√£o criada
        try {
            const AIMonitor = require('./ai-monitoring-integration.js');
            const monitor = new AIMonitor();
            
            const testSignal = {
                action: 'SINAL_LONG',
                ticker: 'BTCUSDT',
                price: 45000,
                rsi: 65,
                fearGreed: 60,
                volume: 'high'
            };

            const analysis = await monitor.analyzeMarketSignal(testSignal);
            console.log(`‚úÖ Teste da fun√ß√£o IA: ${analysis.decision} (confidence: ${analysis.confidence}%)`);

            this.results.openai.tests.push({
                name: 'Fun√ß√£o de monitoramento',
                status: 'success',
                decision: analysis.decision,
                confidence: analysis.confidence
            });

        } catch (error) {
            console.log('‚ö†Ô∏è Erro ao testar fun√ß√£o IA:', error.message);
        }
    }

    async validateStripeIntegration() {
        console.log('üí≥ VALIDANDO INTEGRA√á√ÉO STRIPE...');

        if (!process.env.STRIPE_SECRET_KEY) {
            this.results.stripe.errors.push('Secret Key n√£o configurada');
            this.results.stripe.status = 'error';
            return;
        }

        try {
            const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

            // Teste 1: Conectividade
            console.log('üß™ Teste 1: Conectividade Stripe...');
            const balance = await stripe.balance.retrieve();
            console.log('‚úÖ Conectado ao Stripe, moeda:', balance.available[0]?.currency || 'USD');

            // Teste 2: Criar produtos de teste real
            await this.createRealStripeProducts(stripe);

            // Teste 3: Testar webhooks
            await this.testStripeWebhooks(stripe);

            // Teste 4: Simular fluxo de pagamento completo
            await this.simulatePaymentFlow(stripe);

            this.results.stripe.status = 'success';
            console.log('‚úÖ Stripe completamente integrado e funcional\n');

        } catch (error) {
            console.error('‚ùå Erro Stripe:', error.message);
            this.results.stripe.status = 'error';
            this.results.stripe.errors.push(error.message);
        }
    }

    async createRealStripeProducts(stripe) {
        console.log('üß™ Teste 2: Criando produtos Stripe reais...');

        const realProducts = [
            {
                name: 'CoinBitClub - Plano Mensal Premium',
                description: 'Acesso completo aos sinais de IA e trading automatizado por 30 dias',
                price: 9900, // R$ 99,00
                interval: 'month',
                features: ['Sinais IA em tempo real', 'Trading automatizado', 'Suporte 24/7', 'Dashboard premium']
            },
            {
                name: 'CoinBitClub - Plano Anual VIP',
                description: 'Acesso completo por 12 meses com 20% de desconto',
                price: 95040, // R$ 950,40 (20% desconto)
                interval: 'year',
                features: ['Tudo do plano mensal', '20% de desconto', 'An√°lises exclusivas', 'Mentoria mensal']
            },
            {
                name: 'Recarga Premium R$ 500',
                description: 'Recarga de saldo com 25% de b√¥nus para trading',
                price: 50000, // R$ 500,00
                interval: 'one_time',
                bonus: 25,
                features: ['R$ 500 + R$ 125 b√¥nus', 'V√°lido por 6 meses', 'Trading real']
            },
            {
                name: 'Recarga VIP R$ 1000',
                description: 'Recarga m√°xima com 30% de b√¥nus para traders profissionais',
                price: 100000, // R$ 1000,00
                interval: 'one_time',
                bonus: 30,
                features: ['R$ 1000 + R$ 300 b√¥nus', 'Trading em m√∫ltiplas exchanges', 'Sem limita√ß√µes']
            }
        ];

        for (const productData of realProducts) {
            try {
                // Verificar se produto j√° existe
                const existingProducts = await stripe.products.search({
                    query: `name:'${productData.name}'`
                });

                let product;
                if (existingProducts.data.length > 0) {
                    product = existingProducts.data[0];
                    console.log(`‚ôªÔ∏è Produto existente: ${productData.name}`);
                } else {
                    // Criar novo produto
                    product = await stripe.products.create({
                        name: productData.name,
                        description: productData.description,
                        metadata: {
                            type: productData.interval === 'one_time' ? 'recharge' : 'subscription',
                            bonus_percentage: productData.bonus || 0,
                            features: JSON.stringify(productData.features)
                        }
                    });
                    console.log(`‚úÖ Produto criado: ${productData.name}`);
                }

                // Criar pre√ßo
                const priceConfig = {
                    unit_amount: productData.price,
                    currency: 'brl',
                    product: product.id
                };

                if (productData.interval !== 'one_time') {
                    priceConfig.recurring = { interval: productData.interval };
                }

                const price = await stripe.prices.create(priceConfig);

                // Criar payment link
                const paymentLink = await stripe.paymentLinks.create({
                    line_items: [{
                        price: price.id,
                        quantity: 1
                    }],
                    metadata: {
                        product_type: productData.interval === 'one_time' ? 'recharge' : 'subscription',
                        bonus_percentage: productData.bonus || 0
                    },
                    after_completion: {
                        type: 'redirect',
                        redirect: {
                            url: 'https://coinbitclub.com/success'
                        }
                    }
                });

                // Salvar no banco de dados
                await this.saveStripeProductToDatabase(product, price, paymentLink, productData);

                this.results.stripe.products.push({
                    name: productData.name,
                    price: `R$ ${(productData.price / 100).toFixed(2)}`,
                    link: paymentLink.url,
                    type: productData.interval === 'one_time' ? 'recharge' : 'subscription'
                });

                console.log(`   üí∞ Pre√ßo: R$ ${(productData.price / 100).toFixed(2)}`);
                console.log(`   üîó Link: ${paymentLink.url}`);

            } catch (error) {
                console.log(`‚ùå Erro ao criar produto ${productData.name}:`, error.message);
                this.results.stripe.errors.push(`Produto ${productData.name}: ${error.message}`);
            }
        }
    }

    async saveStripeProductToDatabase(product, price, paymentLink, productData) {
        const client = await this.pool.connect();

        try {
            await client.query(`
                INSERT INTO stripe_products 
                (stripe_product_id, stripe_price_id, name, description, type, price_amount, 
                 currency, interval, bonus_percentage, payment_link, is_active, created_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, true, NOW())
                ON CONFLICT (stripe_product_id) DO UPDATE SET
                stripe_price_id = EXCLUDED.stripe_price_id,
                payment_link = EXCLUDED.payment_link,
                updated_at = NOW()
            `, [
                product.id,
                price.id, 
                productData.name,
                productData.description,
                productData.interval === 'one_time' ? 'recharge' : 'subscription',
                productData.price,
                'BRL',
                productData.interval,
                productData.bonus || 0,
                paymentLink.url
            ]);

        } catch (error) {
            console.log('‚ö†Ô∏è Erro ao salvar produto no banco:', error.message);
        } finally {
            client.release();
        }
    }

    async testStripeWebhooks(stripe) {
        console.log('üß™ Teste 3: Webhooks Stripe...');

        try {
            const webhooks = await stripe.webhookEndpoints.list();
            console.log(`‚úÖ ${webhooks.data.length} webhooks configurados`);

            // Listar eventos importantes
            const events = await stripe.events.list({ limit: 5 });
            console.log(`‚úÖ ${events.data.length} eventos recentes encontrados`);

            this.results.stripe.webhooks = webhooks.data.map(wh => ({
                url: wh.url,
                enabled_events: wh.enabled_events.length,
                status: wh.status
            }));

        } catch (error) {
            console.log('‚ö†Ô∏è Erro ao testar webhooks:', error.message);
        }
    }

    async simulatePaymentFlow(stripe) {
        console.log('üß™ Teste 4: Simulando fluxo de pagamento...');

        try {
            // Criar customer de teste
            const customer = await stripe.customers.create({
                email: 'test@coinbitclub.com',
                name: 'Test User',
                metadata: {
                    source: 'integration_test',
                    account_type: 'testnet'
                }
            });

            console.log(`‚úÖ Customer criado: ${customer.id}`);

            // Simular intent de pagamento (n√£o executamos realmente)
            const paymentIntent = await stripe.paymentIntents.create({
                amount: 9900, // R$ 99,00
                currency: 'brl',
                customer: customer.id,
                metadata: {
                    product_type: 'subscription',
                    test: 'true'
                },
                confirm: false // N√£o confirmar automaticamente
            });

            console.log(`‚úÖ Payment Intent criado: ${paymentIntent.id}`);
            console.log(`   Status: ${paymentIntent.status}`);

            // Limpar dados de teste
            await stripe.customers.del(customer.id);
            console.log('‚úÖ Dados de teste limpos');

        } catch (error) {
            console.log('‚ö†Ô∏è Erro na simula√ß√£o:', error.message);
        }
    }

    async validateTwilioIntegration() {
        console.log('üì± VALIDANDO INTEGRA√á√ÉO TWILIO...');

        if (!process.env.TWILIO_ACCOUNT_SID || !process.env.TWILIO_AUTH_TOKEN) {
            this.results.twilio.errors.push('Credenciais Twilio n√£o configuradas');
            this.results.twilio.status = 'error';
            return;
        }

        try {
            const twilio = require('twilio')(
                process.env.TWILIO_ACCOUNT_SID,
                process.env.TWILIO_AUTH_TOKEN
            );

            // Teste 1: Conectividade
            console.log('üß™ Teste 1: Conectividade Twilio...');
            const account = await twilio.api.accounts(process.env.TWILIO_ACCOUNT_SID).fetch();
            console.log('‚úÖ Conectado ao Twilio, status:', account.status);

            // Teste 2: Listar n√∫meros dispon√≠veis
            console.log('üß™ Teste 2: N√∫meros dispon√≠veis...');
            const phoneNumbers = await twilio.incomingPhoneNumbers.list({ limit: 5 });
            console.log(`‚úÖ ${phoneNumbers.length} n√∫meros dispon√≠veis`);

            if (phoneNumbers.length > 0) {
                console.log(`   üìû N√∫mero principal: ${phoneNumbers[0].phoneNumber}`);
                
                this.results.twilio.services.push({
                    type: 'phone_number',
                    number: phoneNumbers[0].phoneNumber,
                    status: 'active'
                });
            }

            // Teste 3: Criar fun√ß√£o de notifica√ß√£o SMS
            await this.createSMSNotificationSystem(twilio, phoneNumbers[0]?.phoneNumber);

            // Teste 4: Testar envio de SMS (apenas em desenvolvimento)
            if (process.env.NODE_ENV === 'development' && process.env.TEST_PHONE_NUMBER) {
                await this.testSMSSending(twilio, phoneNumbers[0]?.phoneNumber);
            }

            this.results.twilio.status = 'success';
            console.log('‚úÖ Twilio completamente integrado e funcional\n');

        } catch (error) {
            console.error('‚ùå Erro Twilio:', error.message);
            this.results.twilio.status = 'error';
            this.results.twilio.errors.push(error.message);
        }
    }

    async createSMSNotificationSystem(twilio, fromNumber) {
        console.log('üß™ Teste 3: Criando sistema de notifica√ß√µes SMS...');

        const smsSystemCode = `
const twilio = require('twilio')(
    process.env.TWILIO_ACCOUNT_SID,
    process.env.TWILIO_AUTH_TOKEN
);

class CoinbitClubSMSNotifier {
    constructor() {
        this.fromNumber = '${fromNumber || '+1234567890'}';
        this.templates = {
            trade_executed: 'CoinBitClub: Trade executado - {symbol} {side} {quantity} @ ${price}. PnL: {pnl}',
            position_closed: 'CoinBitClub: Posi√ß√£o fechada - {symbol} PnL: {pnl}. Saldo atual: ${balance}',
            signal_received: 'CoinBitClub: Novo sinal - {action} {symbol} @ ${price}',
            account_alert: 'CoinBitClub: ALERTA - {message}. Verifique sua conta.',
            payment_received: 'CoinBitClub: Pagamento recebido - ${amount}. Saldo atualizado.',
            subscription_expires: 'CoinBitClub: Sua assinatura expira em {days} dias. Renove agora!'
        };
    }

    async sendTradeNotification(userPhone, tradeData) {
        try {
            const message = this.formatMessage('trade_executed', {
                symbol: tradeData.symbol,
                side: tradeData.side,
                quantity: tradeData.quantity,
                price: tradeData.price,
                pnl: tradeData.pnl >= 0 ? '+' + tradeData.pnl : tradeData.pnl
            });

            const result = await twilio.messages.create({
                body: message,
                from: this.fromNumber,
                to: userPhone
            });

            console.log(\`üì± SMS enviado: \${result.sid}\`);
            return { success: true, sid: result.sid };

        } catch (error) {
            console.error('‚ùå Erro ao enviar SMS:', error);
            return { success: false, error: error.message };
        }
    }

    async sendSignalAlert(userPhone, signalData) {
        try {
            const message = this.formatMessage('signal_received', {
                action: signalData.action,
                symbol: signalData.symbol,
                price: signalData.price
            });

            const result = await twilio.messages.create({
                body: message,
                from: this.fromNumber,
                to: userPhone
            });

            return { success: true, sid: result.sid };

        } catch (error) {
            return { success: false, error: error.message };
        }
    }

    async sendAccountAlert(userPhone, alertMessage) {
        try {
            const message = this.formatMessage('account_alert', {
                message: alertMessage
            });

            const result = await twilio.messages.create({
                body: message,
                from: this.fromNumber,
                to: userPhone
            });

            return { success: true, sid: result.sid };

        } catch (error) {
            return { success: false, error: error.message };
        }
    }

    formatMessage(template, data) {
        let message = this.templates[template];
        for (const [key, value] of Object.entries(data)) {
            message = message.replace(new RegExp(\`{\${key}}\`, 'g'), value);
        }
        return message;
    }

    async sendBulkNotifications(notifications) {
        const results = [];
        
        for (const notification of notifications) {
            try {
                const result = await twilio.messages.create({
                    body: notification.message,
                    from: this.fromNumber,
                    to: notification.phone
                });
                
                results.push({ 
                    phone: notification.phone, 
                    success: true, 
                    sid: result.sid 
                });
                
                // Rate limiting - aguardar 1 segundo entre envios
                await new Promise(resolve => setTimeout(resolve, 1000));
                
            } catch (error) {
                results.push({ 
                    phone: notification.phone, 
                    success: false, 
                    error: error.message 
                });
            }
        }
        
        return results;
    }
}

module.exports = CoinbitClubSMSNotifier;
`;

        // Salvar sistema de SMS
        require('fs').writeFileSync('./sms-notification-integration.js', smsSystemCode);
        console.log('‚úÖ Sistema de notifica√ß√µes SMS criado: sms-notification-integration.js');

        this.results.twilio.services.push({
            type: 'notification_system',
            status: 'created',
            features: ['trade_notifications', 'signal_alerts', 'account_alerts', 'bulk_notifications']
        });
    }

    async testSMSSending(twilio, fromNumber) {
        console.log('üß™ Teste 4: Enviando SMS de teste...');

        try {
            const testMessage = await twilio.messages.create({
                body: 'CoinBitClub: Sistema SMS funcionando! Integra√ß√£o validada com sucesso.',
                from: fromNumber,
                to: process.env.TEST_PHONE_NUMBER
            });

            console.log(`‚úÖ SMS de teste enviado: ${testMessage.sid}`);
            
            this.results.twilio.services.push({
                type: 'test_sms',
                status: 'sent',
                sid: testMessage.sid
            });

        } catch (error) {
            console.log('‚ö†Ô∏è Erro ao enviar SMS de teste:', error.message);
        }
    }

    async generateIntegrationsReport() {
        console.log('üìä RELAT√ìRIO DE INTEGRA√á√ïES');
        console.log('=============================\n');

        // Status geral
        const integrations = ['openai', 'stripe', 'twilio'];
        const successful = integrations.filter(i => this.results[i].status === 'success').length;
        const total = integrations.length;

        console.log('üéØ RESUMO GERAL:');
        console.log(`   ‚úÖ Integra√ß√µes funcionando: ${successful}/${total}`);
        console.log(`   üìä Taxa de sucesso: ${Math.round((successful/total)*100)}%\n`);

        // OpenAI
        console.log('ü§ñ OPENAI:');
        console.log(`   Status: ${this.getStatusIcon(this.results.openai.status)} ${this.results.openai.status}`);
        if (this.results.openai.tests.length > 0) {
            console.log('   Testes executados:');
            this.results.openai.tests.forEach(test => {
                console.log(`     ‚úÖ ${test.name}: ${test.status}`);
            });
        }
        if (this.results.openai.errors.length > 0) {
            console.log('   Erros:');
            this.results.openai.errors.forEach(error => {
                console.log(`     ‚ùå ${error}`);
            });
        }

        // Stripe
        console.log('\nüí≥ STRIPE:');
        console.log(`   Status: ${this.getStatusIcon(this.results.stripe.status)} ${this.results.stripe.status}`);
        if (this.results.stripe.products.length > 0) {
            console.log('   Produtos criados:');
            this.results.stripe.products.forEach(product => {
                console.log(`     üí∞ ${product.name}: ${product.price} (${product.type})`);
                console.log(`       üîó ${product.link}`);
            });
        }
        if (this.results.stripe.webhooks.length > 0) {
            console.log('   Webhooks configurados:');
            this.results.stripe.webhooks.forEach(webhook => {
                console.log(`     üîó ${webhook.url}: ${webhook.enabled_events} eventos`);
            });
        }

        // Twilio
        console.log('\nüì± TWILIO:');
        console.log(`   Status: ${this.getStatusIcon(this.results.twilio.status)} ${this.results.twilio.status}`);
        if (this.results.twilio.services.length > 0) {
            console.log('   Servi√ßos dispon√≠veis:');
            this.results.twilio.services.forEach(service => {
                console.log(`     üìû ${service.type}: ${service.status}`);
                if (service.number) console.log(`       N√∫mero: ${service.number}`);
                if (service.features) console.log(`       Features: ${service.features.join(', ')}`);
            });
        }

        // Pr√≥ximos passos
        console.log('\nüéØ PR√ìXIMOS PASSOS:');
        
        if (successful === total) {
            console.log('   üöÄ TODAS AS INTEGRA√á√ïES FUNCIONANDO!');
            console.log('   ‚úÖ Sistema pronto para produ√ß√£o');
            console.log('   üìã Links de pagamento dispon√≠veis');
            console.log('   ü§ñ IA integrada e funcional');
            console.log('   üì± SMS notifications ativas');
        } else {
            console.log('   ‚ö†Ô∏è Corrigir integra√ß√µes com falha');
            console.log('   üîß Verificar vari√°veis de ambiente');
            console.log('   üìû Contactar suporte se necess√°rio');
        }

        console.log('\n=============================');
        console.log('‚úÖ VALIDA√á√ÉO DE INTEGRA√á√ïES FINALIZADA');
    }

    getStatusIcon(status) {
        switch(status) {
            case 'success': return '‚úÖ';
            case 'error': return '‚ùå';
            case 'pending': return '‚è≥';
            default: return '‚ö†Ô∏è';
        }
    }
}

// Executar se chamado diretamente
if (require.main === module) {
    const validator = new IntegrationsValidator();
    validator.validateAllIntegrations().catch(error => {
        console.error('üí• FALHA CR√çTICA:', error);
        process.exit(1);
    });
}

module.exports = IntegrationsValidator;
