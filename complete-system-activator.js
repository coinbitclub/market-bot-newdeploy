require('dotenv').config();
const { spawn, exec } = require('child_process');
const axios = require('axios');
const { promisify } = require('util');

/**
 * üî• ATIVADOR COMPLETO DO SISTEMA
 * Configura Ngrok, corrige conectividade e ativa trading real
 */

class SystemActivator {
    constructor() {
        this.execAsync = promisify(exec);
        this.ngrokProcess = null;
        this.publicUrl = null;
    }

    async activateCompleteSystem() {
        console.log('üî• ATIVA√á√ÉO COMPLETA DO SISTEMA DE TRADING');
        console.log('='.repeat(60));
        
        try {
            // 1. Configurar Ngrok
            await this.setupNgrok();
            
            // 2. Iniciar tunnel EU
            await this.startEUTunnel();
            
            // 3. Verificar conectividade
            await this.verifyConnectivity();
            
            // 4. Executar corre√ß√µes de banco
            await this.fixDatabaseErrors();
            
            // 5. Ativar monitoramento
            await this.activateMonitoring();
            
            // 6. Relat√≥rio final
            await this.generateActivationReport();
            
        } catch (error) {
            console.error('‚ùå Erro na ativa√ß√£o:', error);
        }
    }

    async setupNgrok() {
        console.log('\nüîß CONFIGURANDO NGROK');
        console.log('-'.repeat(40));
        
        try {
            // Configurar authtoken se necess√°rio
            console.log('üîë Configurando autentica√ß√£o...');
            
            // Para teste, vamos pular o authtoken por enquanto
            console.log('‚ö†Ô∏è  Usando Ngrok sem authtoken (limitado)');
            
        } catch (error) {
            console.log('‚ö†Ô∏è  Erro na configura√ß√£o:', error.message);
        }
    }

    async startEUTunnel() {
        console.log('\nüåç INICIANDO TUNNEL REGI√ÉO EU');
        console.log('-'.repeat(40));
        
        try {
            // Parar processos existentes
            console.log('üõë Parando tunnels existentes...');
            try {
                await this.execAsync('taskkill /f /im ngrok.exe 2>nul');
            } catch (error) {
                // Processo pode n√£o existir
            }
            
            // Aguardar um pouco
            await this.sleep(2000);
            
            // Iniciar tunnel para regi√£o EU
            console.log('üöÄ Iniciando tunnel EU...');
            
            return new Promise((resolve, reject) => {
                // Usar spawn para manter processo ativo
                this.ngrokProcess = spawn('ngrok', ['http', '3000', '--region=eu'], {
                    stdio: ['ignore', 'pipe', 'pipe']
                });
                
                let outputBuffer = '';
                
                this.ngrokProcess.stdout.on('data', (data) => {
                    const output = data.toString();
                    outputBuffer += output;
                    
                    // Log importante
                    if (output.includes('started tunnel') || output.includes('url=')) {
                        console.log('‚úÖ Tunnel iniciado com sucesso');
                    }
                });
                
                this.ngrokProcess.stderr.on('data', (data) => {
                    console.log(`‚ö†Ô∏è  Ngrok: ${data.toString().trim()}`);
                });
                
                // Aguardar inicializa√ß√£o
                setTimeout(async () => {
                    try {
                        // Verificar tunnels ativos
                        const response = await axios.get('http://localhost:4040/api/tunnels');
                        const tunnels = response.data.tunnels;
                        
                        if (tunnels && tunnels.length > 0) {
                            this.publicUrl = tunnels[0].public_url;
                            console.log(`üîó URL p√∫blica: ${this.publicUrl}`);
                            
                            // Verificar regi√£o
                            if (this.publicUrl.includes('.eu.')) {
                                console.log('‚úÖ Tunnel na regi√£o EU confirmado');
                                resolve(this.publicUrl);
                            } else {
                                console.log('‚ö†Ô∏è  Tunnel n√£o est√° na regi√£o EU');
                                resolve(this.publicUrl);
                            }
                        } else {
                            console.log('‚ùå Nenhum tunnel ativo');
                            reject(new Error('Nenhum tunnel ativo'));
                        }
                    } catch (error) {
                        console.log('‚ùå Erro ao verificar tunnels:', error.message);
                        reject(error);
                    }
                }, 10000);
            });
            
        } catch (error) {
            console.error('‚ùå Erro ao iniciar tunnel:', error.message);
            throw error;
        }
    }

    async verifyConnectivity() {
        console.log('\nüîç VERIFICANDO CONECTIVIDADE');
        console.log('-'.repeat(40));
        
        try {
            // Verificar IP atual
            const ipResponse = await axios.get('https://api.ipify.org?format=json');
            const currentIP = ipResponse.data.ip;
            console.log(`üåê IP atual: ${currentIP}`);
            
            // Verificar geolocaliza√ß√£o
            const geoResponse = await axios.get(`http://ip-api.com/json/${currentIP}`);
            const { country, regionName, city } = geoResponse.data;
            console.log(`üìç Localiza√ß√£o: ${city}, ${regionName}, ${country}`);
            
            // Testar exchanges
            const exchanges = [
                { name: 'Bybit', url: 'https://api.bybit.com/v5/market/time' },
                { name: 'Binance', url: 'https://api.binance.com/api/v3/time' }
            ];
            
            console.log('\nüîó Testando exchanges:');
            for (const exchange of exchanges) {
                try {
                    const startTime = Date.now();
                    await axios.get(exchange.url, { timeout: 5000 });
                    const responseTime = Date.now() - startTime;
                    console.log(`   ‚úÖ ${exchange.name}: ${responseTime}ms`);
                } catch (error) {
                    const status = error.response?.status || 'timeout';
                    console.log(`   ‚ùå ${exchange.name}: ${status}`);
                    
                    if (status === 403) {
                        console.log(`      üîë IP ${currentIP} pode estar bloqueado`);
                    }
                }
            }
            
        } catch (error) {
            console.error('‚ùå Erro na verifica√ß√£o:', error.message);
        }
    }

    async fixDatabaseErrors() {
        console.log('\nüîß EXECUTANDO CORRE√á√ïES DE BANCO');
        console.log('-'.repeat(40));
        
        try {
            console.log('üîÑ Executando auto-error-fixer...');
            
            // Executar o corretor de erros
            const { stdout, stderr } = await this.execAsync('node auto-error-fixer.js', {
                cwd: process.cwd()
            });
            
            if (stdout) {
                console.log('‚úÖ Corre√ß√µes aplicadas:');
                console.log(stdout.substring(0, 500) + '...');
            }
            
            if (stderr) {
                console.log('‚ö†Ô∏è  Avisos:', stderr.substring(0, 200));
            }
            
        } catch (error) {
            console.log('‚ö†Ô∏è  Erro nas corre√ß√µes:', error.message.substring(0, 100));
        }
    }

    async activateMonitoring() {
        console.log('\nüìä ATIVANDO MONITORAMENTO');
        console.log('-'.repeat(40));
        
        try {
            // Verificar se o servidor est√° rodando
            console.log('üîÑ Verificando servidor local...');
            
            try {
                await axios.get('http://localhost:3000/api/health', { timeout: 5000 });
                console.log('‚úÖ Servidor local est√° rodando');
            } catch (error) {
                console.log('‚ö†Ô∏è  Servidor local n√£o est√° rodando');
                console.log('üí° Para iniciar: npm start ou node app.js');
            }
            
            // Verificar Railway
            console.log('üîÑ Verificando Railway...');
            
            try {
                const railwayUrl = 'https://coinbitclub-market-bot-backend-production.up.railway.app';
                await axios.get(`${railwayUrl}/api/health`, { timeout: 10000 });
                console.log('‚úÖ Railway est√° respondendo');
            } catch (error) {
                const status = error.response?.status || 'timeout';
                if (status === 404) {
                    console.log('‚ö†Ô∏è  Railway: endpoint /api/health n√£o encontrado');
                } else {
                    console.log(`‚ö†Ô∏è  Railway: ${status}`);
                }
            }
            
        } catch (error) {
            console.error('‚ùå Erro no monitoramento:', error.message);
        }
    }

    async generateActivationReport() {
        console.log('\nüìä RELAT√ìRIO DE ATIVA√á√ÉO');
        console.log('='.repeat(60));
        
        console.log('üî• STATUS DO SISTEMA:');
        console.log(`   üåç Ngrok URL: ${this.publicUrl || 'N√£o dispon√≠vel'}`);
        console.log(`   ‚ö° Tunnel ativo: ${this.ngrokProcess ? 'Sim' : 'N√£o'}`);
        console.log(`   üì° Regi√£o: EU (configurada)`);
        
        console.log('\nüöÄ PR√ìXIMAS A√á√ïES:');
        console.log('   1. ‚úÖ Verificar se app.js est√° rodando localmente');
        console.log('   2. üì° Configurar webhooks TradingView para usar Ngrok URL');
        console.log('   3. üîë Adicionar IPs nas whitelists das exchanges');
        console.log('   4. üìä Monitorar logs em tempo real');
        console.log('   5. üéØ Testar recep√ß√£o de sinais');
        
        console.log('\nüí° COMANDOS √öTEIS:');
        console.log('   ‚Ä¢ Iniciar servidor: node app.js');
        console.log('   ‚Ä¢ Verificar tunnels: curl http://localhost:4040/api/tunnels');
        console.log('   ‚Ä¢ Testar webhook: curl [NGROK_URL]/webhook/test');
        console.log('   ‚Ä¢ Ver logs: tail -f logs/app.log');
        
        if (this.publicUrl) {
            console.log(`\nüîó URL PARA WEBHOOKS TRADINGVIEW:`);
            console.log(`   ${this.publicUrl}/webhook/tradingview`);
            console.log(`   ${this.publicUrl}/api/webhook/signal`);
        }
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Cleanup ao sair
    async cleanup() {
        if (this.ngrokProcess) {
            console.log('üõë Finalizando tunnel Ngrok...');
            this.ngrokProcess.kill();
        }
    }
}

// Executar ativa√ß√£o
if (require.main === module) {
    const activator = new SystemActivator();
    
    // Cleanup ao sair
    process.on('SIGINT', async () => {
        await activator.cleanup();
        process.exit(0);
    });
    
    activator.activateCompleteSystem();
}

module.exports = SystemActivator;
