#!/usr/bin/env node

/**
 * üîê TESTE DE CONEX√ÉO COM CHAVES DESCRIPTOGRAFADAS
 * ===============================================
 * 
 * Script para testar conex√µes enterprise usando as chaves reais descriptografadas
 */

const { Pool } = require('pg');
const EnterpriseExchangeConnector = require('./enterprise-exchange-connector');
const crypto = require('crypto');

const pool = new Pool({
    connectionString: process.env.DATABASE_URL || 'postgresql://postgres:ELjbkkgUASRCtdTAXVFgIssOXiLsRCPq@trolley.proxy.rlwy.net:44790/railway',
    ssl: { rejectUnauthorized: false }
});

class DecryptorService {
    constructor() {
        // Chave de criptografia padr√£o (mesmo do sistema original)
        this.encryptionKey = process.env.ENCRYPTION_KEY || 'CoinBitClubSecretKey32CharsForProd';
    }

    async decryptUserKeys(encryptedKey, encryptedSecret) {
        try {
            const algorithm = 'aes-256-cbc';
            const key = crypto.scryptSync(this.encryptionKey, 'salt', 32);

            // Descriptografar API Key
            const keyBuffer = Buffer.from(encryptedKey, 'hex');
            const keyIv = keyBuffer.slice(0, 16);
            const keyEncrypted = keyBuffer.slice(16);
            const keyDecipher = crypto.createDecipheriv(algorithm, key, keyIv);
            const apiKey = keyDecipher.update(keyEncrypted, null, 'utf8') + keyDecipher.final('utf8');

            // Descriptografar API Secret
            const secretBuffer = Buffer.from(encryptedSecret, 'hex');
            const secretIv = secretBuffer.slice(0, 16);
            const secretEncrypted = secretBuffer.slice(16);
            const secretDecipher = crypto.createDecipheriv(algorithm, key, secretIv);
            const apiSecret = secretDecipher.update(secretEncrypted, null, 'utf8') + secretDecipher.final('utf8');

            return {
                success: true,
                apiKey,
                apiSecret
            };
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
}

async function testarConexoesDescriptografadas() {
    console.log('üîê TESTANDO CONEX√ïES COM CHAVES DESCRIPTOGRAFADAS');
    console.log('================================================');

    const connector = new EnterpriseExchangeConnector();
    const decryptor = new DecryptorService();
    
    try {
        // 1. Buscar usu√°rios com chaves criptografadas
        console.log('\nüîç BUSCANDO CHAVES CRIPTOGRAFADAS...');

        const chavesUsuarios = await pool.query(`
            SELECT 
                uak.id,
                u.id as user_id,
                u.username,
                u.email,
                uak.exchange,
                uak.environment,
                uak.api_key_encrypted,
                uak.secret_key_encrypted,
                uak.api_key_iv,
                uak.secret_key_iv,
                uak.is_active,
                uak.last_validated
            FROM user_api_keys uak
            JOIN users u ON uak.user_id = u.id
            WHERE u.is_active = true
            AND uak.is_active = true
            AND uak.api_key_encrypted IS NOT NULL
            AND uak.secret_key_encrypted IS NOT NULL
            ORDER BY u.id, uak.exchange, uak.environment
        `);

        if (chavesUsuarios.rows.length === 0) {
            console.log('‚ùå Nenhuma chave criptografada v√°lida encontrada');
            return;
        }

        console.log(`‚úÖ Encontradas ${chavesUsuarios.rows.length} chaves criptografadas para testar`);

        // 2. Testar cada chave
        let sucessos = 0;
        let falhas = 0;
        let errosDescriptografia = 0;

        for (const chaveData of chavesUsuarios.rows) {
            console.log(`\nüë§ TESTANDO: ${chaveData.username} (ID: ${chaveData.user_id})`);
            console.log(`üìß Email: ${chaveData.email}`);
            console.log(`üîë Chave ID: ${chaveData.id}`);
            console.log(`üìä Exchange: ${chaveData.exchange} ${chaveData.environment}`);
            console.log(`üïê √öltima valida√ß√£o: ${chaveData.last_validated || 'Nunca'}`);
            console.log('‚îÄ'.repeat(60));

            try {
                // Descriptografar as chaves
                console.log('  üîì Descriptografando chaves...');
                
                const decryptResult = await decryptor.decryptUserKeys(
                    chaveData.api_key_encrypted,
                    chaveData.secret_key_encrypted
                );

                if (!decryptResult.success) {
                    console.log(`  ‚ùå Erro na descriptografia: ${decryptResult.error}`);
                    errosDescriptografia++;
                    continue;
                }

                const { apiKey, apiSecret } = decryptResult;
                
                console.log(`  ‚úÖ Chaves descriptografadas com sucesso`);
                console.log(`  üîë API Key: ${apiKey.substring(0, 8)}...${apiKey.substring(-4)}`);
                console.log(`  üîê Secret: ${apiSecret ? '***Presente***' : 'AUSENTE'}`);

                // Testar conex√£o enterprise
                console.log('  üîÑ Testando conex√£o enterprise...');
                
                const startTime = Date.now();
                
                const resultado = await connector.connectAndValidateExchange(
                    chaveData.user_id,
                    apiKey,
                    apiSecret,
                    chaveData.exchange.toLowerCase()
                );

                const tempoExecucao = Date.now() - startTime;

                if (resultado.success) {
                    console.log(`  ‚úÖ SUCESSO! (${tempoExecucao}ms)`);
                    console.log(`     üéØ Exchange detectada: ${resultado.exchange} ${resultado.environment}`);
                    console.log(`     üìä Conta: ${resultado.accountInfo?.accountType || 'N/A'}`);
                    
                    if (resultado.accountInfo?.totalWalletBalance) {
                        console.log(`     üí∞ Saldo total: ${resultado.accountInfo.totalWalletBalance} USDT`);
                    }
                    
                    if (resultado.balances && resultado.balances.length > 0) {
                        const saldosPositivos = resultado.balances.filter(b => parseFloat(b.free) > 0);
                        console.log(`     üíº Ativos: ${resultado.balances.length} moedas (${saldosPositivos.length} com saldo)`);
                        
                        if (saldosPositivos.length > 0) {
                            console.log(`     üíé Top 3 ativos:`);
                            saldosPositivos
                                .sort((a, b) => parseFloat(b.free) - parseFloat(a.free))
                                .slice(0, 3)
                                .forEach(asset => {
                                    console.log(`       - ${asset.asset}: ${asset.free}`);
                                });
                        }
                    }

                    // Atualizar status no banco
                    await pool.query(`
                        UPDATE user_api_keys 
                        SET 
                            last_validated = NOW(),
                            validation_status = 'valid',
                            validation_error = NULL
                        WHERE id = $1
                    `, [chaveData.id]);

                    sucessos++;
                } else {
                    console.log(`  ‚ùå FALHA! (${tempoExecucao}ms)`);
                    console.log(`     üîç Motivo: ${resultado.error}`);
                    console.log(`     üìã Detalhes: ${resultado.details || 'N/A'}`);

                    // Atualizar status no banco
                    await pool.query(`
                        UPDATE user_api_keys 
                        SET 
                            last_validated = NOW(),
                            validation_status = 'invalid',
                            validation_error = $2
                        WHERE id = $1
                    `, [chaveData.id, resultado.error]);

                    falhas++;
                }

            } catch (error) {
                console.log(`  üí• ERRO CR√çTICO!`);
                console.log(`     ‚ùå ${error.message}`);

                // Atualizar status no banco
                await pool.query(`
                    UPDATE user_api_keys 
                    SET 
                        last_validated = NOW(),
                        validation_status = 'error',
                        validation_error = $2
                    WHERE id = $1
                `, [chaveData.id, error.message]);

                falhas++;
            }

            // Pausa entre testes
            await new Promise(resolve => setTimeout(resolve, 2000));
        }

        // 3. Relat√≥rio final
        console.log('\n\nüìä RELAT√ìRIO FINAL DE TESTES');
        console.log('============================');

        const total = sucessos + falhas + errosDescriptografia;
        
        console.log(`‚úÖ Conex√µes bem-sucedidas: ${sucessos}`);
        console.log(`‚ùå Conex√µes falhadas: ${falhas}`);
        console.log(`üîê Erros de descriptografia: ${errosDescriptografia}`);
        console.log(`üìä Total testado: ${total}`);

        if (total > 0) {
            const taxaSucesso = ((sucessos / total) * 100).toFixed(1);
            console.log(`üìà Taxa de sucesso: ${taxaSucesso}%`);
        }

        // 4. Estado atual do sistema enterprise
        console.log('\nüè¢ ESTADO DO SISTEMA ENTERPRISE:');
        console.log('===============================');

        const estadoEnterprise = await pool.query(`
            SELECT 
                COUNT(*) as total_conexoes,
                COUNT(CASE WHEN is_active = true THEN 1 END) as conexoes_ativas,
                COUNT(DISTINCT user_id) as usuarios_conectados,
                COUNT(CASE WHEN last_validated > NOW() - INTERVAL '1 hour' THEN 1 END) as validadas_recentemente
            FROM user_exchange_connections
        `);

        const estado = estadoEnterprise.rows[0];
        console.log(`üîó Total de conex√µes enterprise: ${estado.total_conexoes}`);
        console.log(`‚úÖ Conex√µes ativas: ${estado.conexoes_ativas}`);
        console.log(`üë• Usu√°rios conectados: ${estado.usuarios_conectados}`);
        console.log(`‚è∞ Validadas na √∫ltima hora: ${estado.validadas_recentemente}`);

        // 5. Resumo de valida√ß√µes
        console.log('\nüìã STATUS DAS VALIDA√á√ïES:');

        const statusValidacoes = await pool.query(`
            SELECT 
                validation_status,
                COUNT(*) as quantidade
            FROM user_api_keys
            WHERE is_active = true
            GROUP BY validation_status
            ORDER BY quantidade DESC
        `);

        for (const status of statusValidacoes.rows) {
            const emoji = status.validation_status === 'valid' ? '‚úÖ' : 
                         status.validation_status === 'invalid' ? '‚ùå' : 
                         status.validation_status === 'error' ? 'üí•' : '‚ö†Ô∏è';
            console.log(`  ${emoji} ${status.validation_status || 'pending'}: ${status.quantidade} chaves`);
        }

    } catch (error) {
        console.error('\n‚ùå Erro no teste:', error.message);
        console.error('Stack:', error.stack);
    } finally {
        await pool.end();
    }
}

// Executar se chamado diretamente
if (require.main === module) {
    testarConexoesDescriptografadas()
        .then(() => {
            console.log('\n‚úÖ TESTE COM CHAVES DESCRIPTOGRAFADAS CONCLU√çDO!');
            process.exit(0);
        })
        .catch((error) => {
            console.error('\nüí• ERRO:', error.message);
            process.exit(1);
        });
}

module.exports = { testarConexoesDescriptografadas };
