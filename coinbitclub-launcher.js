#!/usr/bin/env node

/**
 * üöÄ INICIALIZA√á√ÉO PRINCIPAL - COINBITCLUB MARKET BOT
 * ===================================================
 * 
 * Sistema de inicializa√ß√£o autom√°tica completo que:
 * - Valida todas as conex√µes automaticamente
 * - Inicializa o sistema de trading
 * - Mant√©m monitoramento cont√≠nuo
 * - Garante reconex√£o autom√°tica
 * 
 * ESPECIALISTA: SEM FUROS, TUDO AUTOM√ÅTICO
 */

const SistemaValidacaoAutomatica = require('./sistema-validacao-automatica');
const IntegradorExecutores = require('./integrador-executores');
const { Pool } = require('pg');
const express = require('express');
const cron = require('node-cron');

class CoinbitClubSystemLauncher {
    constructor() {
        this.sistemaValidacao = new SistemaValidacaoAutomatica();
        this.integradorExecutores = new IntegradorExecutores();
        this.app = express();
        this.port = process.env.PORT || 3000;
        this.isSystemRunning = false;
        this.startTime = Date.now();
        
        console.log('üöÄ COINBITCLUB MARKET BOT - INICIANDO...');
    }

    /**
     * üîß CONFIGURAR SERVIDOR EXPRESS
     */
    setupExpressServer() {
        this.app.use(express.json());

        // Endpoint de sa√∫de do sistema
        this.app.get('/health', (req, res) => {
            const stats = this.sistemaValidacao.getSystemStats();
            res.json({
                status: this.isSystemRunning ? 'RUNNING' : 'STOPPED',
                uptime: Date.now() - this.startTime,
                system_stats: stats,
                timestamp: new Date().toISOString()
            });
        });

        // Endpoint para for√ßar revalida√ß√£o
        this.app.post('/revalidate', async (req, res) => {
            try {
                console.log('üîÑ Revalida√ß√£o for√ßada solicitada via API');
                const success = await this.sistemaValidacao.executarValidacaoCompleta();
                res.json({
                    success,
                    message: success ? 'Revalida√ß√£o conclu√≠da' : 'Falha na revalida√ß√£o',
                    timestamp: new Date().toISOString()
                });
            } catch (error) {
                res.status(500).json({
                    success: false,
                    error: error.message,
                    timestamp: new Date().toISOString()
                });
            }
        });

        // Endpoint para obter conex√µes validadas
        this.app.get('/connections', (req, res) => {
            const validatedConnections = Array.from(this.sistemaValidacao.validatedConnections.entries()).map(([key, connection]) => ({
                key,
                username: connection.username,
                exchange: connection.exchange,
                environment: connection.environment,
                balance: connection.balance,
                last_validated: connection.lastValidated
            }));

            res.json({
                total: validatedConnections.length,
                connections: validatedConnections,
                timestamp: new Date().toISOString()
            });
        });

        // Endpoint para status dos executores
        this.app.get('/executors', (req, res) => {
            const status = this.integradorExecutores.getSystemStatus();
            res.json({
                ...status,
                timestamp: new Date().toISOString()
            });
        });

        // Endpoint para executar trade autom√°tico
        this.app.post('/execute-trade', async (req, res) => {
            try {
                const { userId, exchange, environment, symbol, side, amount, orderType = 'market' } = req.body;
                
                if (!this.integradorExecutores.tradingEnabled) {
                    return res.status(503).json({
                        success: false,
                        error: 'Trading n√£o est√° habilitado'
                    });
                }

                const executor = this.integradorExecutores.getExecutorForTrading(userId, exchange, environment);
                if (!executor) {
                    return res.status(404).json({
                        success: false,
                        error: 'Executor n√£o encontrado ou n√£o ativo'
                    });
                }

                const result = await executor.executeTrade(symbol, side, amount, orderType);
                res.json(result);

            } catch (error) {
                res.status(500).json({
                    success: false,
                    error: error.message
                });
            }
        });

        console.log('üåê Servidor Express configurado');
    }

    /**
     * ‚è∞ CONFIGURAR TAREFAS AGENDADAS
     */
    setupScheduledTasks() {
        // Revalida√ß√£o a cada 5 minutos
        cron.schedule('*/5 * * * *', async () => {
            console.log('‚è∞ Revalida√ß√£o agendada iniciando...');
            try {
                await this.sistemaValidacao.executarValidacaoCompleta();
                console.log('‚úÖ Revalida√ß√£o agendada conclu√≠da');
            } catch (error) {
                console.error('‚ùå Erro na revalida√ß√£o agendada:', error.message);
            }
        });

        // Health check das conex√µes a cada minuto
        cron.schedule('* * * * *', async () => {
            try {
                await this.sistemaValidacao.verificarSaudeConexoes();
            } catch (error) {
                console.error('‚ùå Erro no health check:', error.message);
            }
        });

        // Relat√≥rio detalhado a cada hora
        cron.schedule('0 * * * *', () => {
            console.log('\nüìä RELAT√ìRIO HOR√ÅRIO DO SISTEMA');
            console.log('==============================');
            this.sistemaValidacao.gerarRelatorioValidacao();
        });

        console.log('‚è∞ Tarefas agendadas configuradas');
    }

    /**
     * üîß VERIFICAR DEPEND√äNCIAS
     */
    async verificarDependencias() {
        console.log('üîß Verificando depend√™ncias...');
        
        const dependencias = [
            { nome: 'PostgreSQL', teste: () => this.testarBanco() },
            { nome: 'Conectividade Internet', teste: () => this.testarInternet() },
            { nome: 'Estrutura do Banco', teste: () => this.verificarEstruturaBanco() }
        ];

        for (const dep of dependencias) {
            try {
                await dep.teste();
                console.log(`‚úÖ ${dep.nome}: OK`);
            } catch (error) {
                console.error(`‚ùå ${dep.nome}: FALHA - ${error.message}`);
                throw new Error(`Depend√™ncia ${dep.nome} n√£o atendida`);
            }
        }

        console.log('‚úÖ Todas as depend√™ncias verificadas');
    }

    async testarBanco() {
        const pool = new Pool({
            connectionString: process.env.DATABASE_URL || 'postgresql://postgres:ELjbkkgUASRCtdTAXVFgIssOXiLsRCPq@trolley.proxy.rlwy.net:44790/railway',
            ssl: { rejectUnauthorized: false }
        });

        const result = await pool.query('SELECT NOW()');
        await pool.end();
        
        if (!result.rows[0]) {
            throw new Error('Sem resposta do banco');
        }
    }

    async testarInternet() {
        const axios = require('axios');
        await axios.get('https://api.ipify.org', { timeout: 5000 });
    }

    async verificarEstruturaBanco() {
        const pool = new Pool({
            connectionString: process.env.DATABASE_URL || 'postgresql://postgres:ELjbkkgUASRCtdTAXVFgIssOXiLsRCPq@trolley.proxy.rlwy.net:44790/railway',
            ssl: { rejectUnauthorized: false }
        });

        // Verificar tabelas essenciais
        const tabelas = ['users', 'user_api_keys', 'trading_executions'];
        
        for (const tabela of tabelas) {
            const result = await pool.query(`
                SELECT EXISTS (
                    SELECT FROM information_schema.tables 
                    WHERE table_schema = 'public' 
                    AND table_name = $1
                );
            `, [tabela]);

            if (!result.rows[0].exists) {
                await pool.end();
                throw new Error(`Tabela ${tabela} n√£o existe`);
            }
        }

        await pool.end();
    }

    /**
     * üöÄ INICIALIZA√á√ÉO PRINCIPAL
     */
    async iniciar() {
        try {
            console.log('\nüöÄ INICIALIZANDO COINBITCLUB MARKET BOT');
            console.log('======================================');

            // 1. Verificar depend√™ncias
            await this.verificarDependencias();

            // 2. Configurar servidor
            this.setupExpressServer();

            // 3. Configurar tarefas agendadas
            this.setupScheduledTasks();

            // 4. Inicializar integrador de executores
            await this.integradorExecutores.inicializarIntegracao();

            // 5. Iniciar servidor
            this.app.listen(this.port, () => {
                console.log(`üåê Servidor rodando na porta ${this.port}`);
            });

            // 6. Marcar sistema como rodando
            this.isSystemRunning = true;

            console.log('\nüéâ COINBITCLUB MARKET BOT TOTALMENTE OPERACIONAL');
            console.log('===============================================');
            console.log(`üì° API: http://localhost:${this.port}`);
            console.log('üìã Endpoints dispon√≠veis:');
            console.log('   GET  /health - Status do sistema');
            console.log('   GET  /connections - Conex√µes validadas');
            console.log('   GET  /executors - Status dos executores');
            console.log('   POST /revalidate - For√ßar revalida√ß√£o');
            console.log('   POST /execute-trade - Executar trade autom√°tico');
            console.log('\nüîÑ Sistema rodando em modo autom√°tico...');

            return true;

        } catch (error) {
            console.error('‚ùå FALHA NA INICIALIZA√á√ÉO:', error.message);
            console.error('üõë O sistema ser√° encerrado.');
            process.exit(1);
        }
    }

    /**
     * üõë PARADA SEGURA
     */
    async pararSistema() {
        console.log('\nüõë INICIANDO PARADA SEGURA DO SISTEMA');
        
        try {
            this.isSystemRunning = false;
            
            // Parar sistema de valida√ß√£o
            await this.sistemaValidacao.pararSistema();
            
            console.log('‚úÖ Sistema parado com seguran√ßa');
            process.exit(0);
            
        } catch (error) {
            console.error('‚ùå Erro na parada do sistema:', error.message);
            process.exit(1);
        }
    }
}

// Handlers de sinais do sistema
process.on('SIGINT', async () => {
    if (global.coinbitClubLauncher) {
        await global.coinbitClubLauncher.pararSistema();
    } else {
        process.exit(0);
    }
});

process.on('SIGTERM', async () => {
    if (global.coinbitClubLauncher) {
        await global.coinbitClubLauncher.pararSistema();
    } else {
        process.exit(0);
    }
});

// Executar se chamado diretamente
if (require.main === module) {
    const launcher = new CoinbitClubSystemLauncher();
    global.coinbitClubLauncher = launcher;
    launcher.iniciar();
}

module.exports = CoinbitClubSystemLauncher;
