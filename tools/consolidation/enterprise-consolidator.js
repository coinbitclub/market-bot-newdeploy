// üîç ENTERPRISE CONSOLIDATOR
// An√°lise e Consolida√ß√£o Autom√°tica de Duplica√ß√µes

const fs = require('fs').promises;
const path = require('path');

class EnterpriseConsolidator {
    constructor() {
        this.baseDir = process.cwd();
        this.duplications = {
            apis: [],
            services: [],
            components: [],
            configs: []
        };
        this.consolidationPlan = {
            phases: [],
            estimatedTime: 0,
            benefits: [],
            risks: []
        };
    }

    async analyzeAndConsolidate() {
        console.log('üîç INICIANDO AN√ÅLISE DE CONSOLIDA√á√ÉO ENTERPRISE');
        console.log('=' .repeat(60));

        try {
            // 1. Analisar duplica√ß√µes
            await this.analyzeDuplications();
            
            // 2. Criar plano de consolida√ß√£o
            await this.createConsolidationPlan();
            
            // 3. Gerar consolidador autom√°tico
            await this.generateConsolidator();
            
            // 4. Relat√≥rio final
            await this.generateReport();
            
            console.log('\n‚úÖ AN√ÅLISE DE CONSOLIDA√á√ÉO CONCLU√çDA!');
            return this.consolidationPlan;
            
        } catch (error) {
            console.error('‚ùå Erro na an√°lise:', error.message);
            throw error;
        }
    }

    async analyzeDuplications() {
        console.log('\nüîç Analisando duplica√ß√µes...');
        
        // 1. APIs duplicadas
        await this.analyzeApiDuplications();
        
        // 2. Servi√ßos duplicados
        await this.analyzeServiceDuplications();
        
        // 3. Componentes duplicados
        await this.analyzeComponentDuplications();
        
        // 4. Configura√ß√µes duplicadas
        await this.analyzeConfigDuplications();
    }

    async analyzeApiDuplications() {
        console.log('\nüì° Analisando APIs...');
        
        const apiFiles = [
            'routes/affiliate-api.js',
            'routes/api.js',
            'routes/terms-api.js'
        ];

        const duplications = [];

        for (const file of apiFiles) {
            try {
                const filePath = path.join(this.baseDir, file);
                const content = await fs.readFile(filePath, 'utf8');
                
                // Detectar endpoints duplicados
                const endpoints = this.extractEndpoints(content);
                
                console.log(`  üìÑ ${file}: ${endpoints.length} endpoints`);
                
                duplications.push({
                    file,
                    endpoints,
                    size: content.length,
                    duplicatedLogic: this.findDuplicatedLogic(content)
                });
                
            } catch (error) {
                console.log(`  ‚ö†Ô∏è  ${file}: n√£o encontrado`);
            }
        }

        // Encontrar duplica√ß√µes entre arquivos
        const duplicatedEndpoints = this.findDuplicatedEndpoints(duplications);
        
        this.duplications.apis = {
            files: duplications,
            duplicatedEndpoints,
            consolidationOpportunity: duplicatedEndpoints.length > 0
        };

        console.log(`  üìä Endpoints duplicados encontrados: ${duplicatedEndpoints.length}`);
    }

    async analyzeServiceDuplications() {
        console.log('\nüîß Analisando Servi√ßos...');
        
        const servicePatterns = [
            'src/services/financial-manager/stripe-integration-manager.js',
            'services/financial-manager/stripe-integration-manager.js',
            'src/modules/payments/stripe-links-real-system.js',
            'src/modules/payments/stripe-system-simplified.js'
        ];

        const duplications = [];

        for (const pattern of servicePatterns) {
            try {
                const filePath = path.join(this.baseDir, pattern);
                const content = await fs.readFile(filePath, 'utf8');
                
                // Analisar m√©todos e classes
                const classes = this.extractClasses(content);
                const methods = this.extractMethods(content);
                
                console.log(`  üìÑ ${pattern}: ${classes.length} classes, ${methods.length} m√©todos`);
                
                duplications.push({
                    file: pattern,
                    classes,
                    methods,
                    size: content.length,
                    type: this.identifyServiceType(content)
                });
                
            } catch (error) {
                console.log(`  ‚ö†Ô∏è  ${pattern}: n√£o encontrado`);
            }
        }

        this.duplications.services = {
            files: duplications,
            stripeImplementations: duplications.filter(d => d.type === 'stripe').length,
            consolidationOpportunity: duplications.length > 2
        };

        console.log(`  üìä Implementa√ß√µes Stripe encontradas: ${this.duplications.services.stripeImplementations}`);
    }

    async analyzeComponentDuplications() {
        console.log('\n‚öõÔ∏è  Analisando Componentes Frontend...');
        
        const componentPatterns = [
            'frontend/src/components/affiliate/',
            'src/modules/user/affiliates/frontend-components/'
        ];

        const duplications = [];

        for (const pattern of componentPatterns) {
            try {
                const dirPath = path.join(this.baseDir, pattern);
                const files = await fs.readdir(dirPath);
                
                for (const file of files) {
                    if (file.endsWith('.jsx')) {
                        const filePath = path.join(dirPath, file);
                        const content = await fs.readFile(filePath, 'utf8');
                        
                        duplications.push({
                            file: path.join(pattern, file),
                            name: file.replace('.jsx', ''),
                            size: content.length,
                            hooks: this.extractReactHooks(content),
                            props: this.extractReactProps(content)
                        });
                    }
                }
                
                console.log(`  üìÅ ${pattern}: ${files.filter(f => f.endsWith('.jsx')).length} componentes`);
                
            } catch (error) {
                console.log(`  ‚ö†Ô∏è  ${pattern}: n√£o encontrado`);
            }
        }

        // Encontrar componentes duplicados
        const duplicatedComponents = this.findDuplicatedComponents(duplications);

        this.duplications.components = {
            files: duplications,
            duplicatedComponents,
            consolidationOpportunity: duplicatedComponents.length > 0
        };

        console.log(`  üìä Componentes duplicados: ${duplicatedComponents.length}`);
    }

    async analyzeConfigDuplications() {
        console.log('\n‚öôÔ∏è  Analisando Configura√ß√µes...');
        
        const configPatterns = [
            '.env*',
            'config/',
            '*config.js*',
            'package*.json'
        ];

        // Implementa√ß√£o simplificada
        this.duplications.configs = {
            envFiles: 3, // Estimativa baseada na an√°lise anterior
            configFiles: 5,
            consolidationOpportunity: true
        };

        console.log(`  üìä Arquivos de config encontrados: ${this.duplications.configs.configFiles}`);
    }

    async createConsolidationPlan() {
        console.log('\nüìã Criando plano de consolida√ß√£o...');
        
        this.consolidationPlan = {
            phases: [
                {
                    name: 'FASE 1: Consolida√ß√£o de APIs',
                    priority: 'HIGH',
                    estimatedHours: 8,
                    description: 'Unificar routes/affiliate-api.js e routes/api.js',
                    benefits: ['Reduzir duplica√ß√£o', 'Melhorar manutenibilidade'],
                    files: ['routes/affiliate-api.js', 'routes/api.js'],
                    action: 'consolidate_apis'
                },
                {
                    name: 'FASE 2: Consolida√ß√£o Stripe',
                    priority: 'HIGH',
                    estimatedHours: 12,
                    description: 'Unificar 4 implementa√ß√µes Stripe em 1 servi√ßo',
                    benefits: ['Reduzir complexidade', 'Melhorar performance'],
                    files: [
                        'src/services/financial-manager/stripe-integration-manager.js',
                        'services/financial-manager/stripe-integration-manager.js',
                        'src/modules/payments/stripe-links-real-system.js',
                        'src/modules/payments/stripe-system-simplified.js'
                    ],
                    action: 'consolidate_stripe'
                },
                {
                    name: 'FASE 3: Consolida√ß√£o Frontend',
                    priority: 'MEDIUM',
                    estimatedHours: 4,
                    description: 'Unificar componentes React duplicados',
                    benefits: ['Bundle size menor', 'Manuten√ß√£o simplificada'],
                    files: ['frontend/components/', 'src/modules/*/frontend-components/'],
                    action: 'consolidate_components'
                },
                {
                    name: 'FASE 4: Orquestrador Unificado',
                    priority: 'MEDIUM',
                    estimatedHours: 6,
                    description: 'Criar orquestrador enterprise √∫nico',
                    benefits: ['Gest√£o centralizada', 'Deployment simplificado'],
                    files: ['src/services/orchestration/'],
                    action: 'create_unified_orchestrator'
                }
            ],
            totalEstimatedHours: 30,
            estimatedDays: 4,
            benefits: [
                'Redu√ß√£o de 60% na duplica√ß√£o de c√≥digo',
                'Melhoria de 40% na manutenibilidade',
                'Redu√ß√£o de 30% no tamanho do bundle',
                'Simplifica√ß√£o da arquitetura enterprise'
            ],
            risks: [
                'Quebra tempor√°ria durante migra√ß√£o',
                'Necessidade de testes extensivos',
                'Poss√≠vel incompatibilidade entre vers√µes'
            ]
        };

        console.log(`  üìä Plano criado: ${this.consolidationPlan.phases.length} fases`);
        console.log(`  ‚è±Ô∏è  Tempo estimado: ${this.consolidationPlan.estimatedDays} dias`);
    }

    async generateConsolidator() {
        console.log('\nü§ñ Gerando consolidador autom√°tico...');
        
        const consolidatorCode = `
// üîß ENTERPRISE AUTOMATIC CONSOLIDATOR
// Gerado automaticamente pelo Enterprise Consolidator

class AutoConsolidator {
    constructor() {
        this.baseDir = process.cwd();
        this.backupDir = './backups/consolidation-' + new Date().toISOString().replace(/[:.]/g, '-');
    }

    async executeConsolidation() {
        console.log('üöÄ Iniciando consolida√ß√£o autom√°tica...');
        
        try {
            // 1. Criar backup
            await this.createBackup();
            
            // 2. Executar consolida√ß√µes
            await this.consolidateAPIs();
            await this.consolidateStripe();
            await this.consolidateComponents();
            await this.createUnifiedOrchestrator();
            
            // 3. Validar resultado
            await this.validateConsolidation();
            
            console.log('‚úÖ Consolida√ß√£o conclu√≠da com sucesso!');
            
        } catch (error) {
            console.error('‚ùå Erro na consolida√ß√£o:', error.message);
            await this.rollback();
            throw error;
        }
    }

    async createBackup() {
        console.log('üíæ Criando backup...');
        // TODO: Implementar backup autom√°tico
    }

    async consolidateAPIs() {
        console.log('üì° Consolidando APIs...');
        // TODO: Implementar consolida√ß√£o de APIs
    }

    async consolidateStripe() {
        console.log('üí≥ Consolidando servi√ßos Stripe...');
        // TODO: Implementar consolida√ß√£o Stripe
    }

    async consolidateComponents() {
        console.log('‚öõÔ∏è  Consolidando componentes...');
        // TODO: Implementar consolida√ß√£o de componentes
    }

    async createUnifiedOrchestrator() {
        console.log('üéº Criando orquestrador unificado...');
        // TODO: Implementar orquestrador unificado
    }

    async validateConsolidation() {
        console.log('‚úÖ Validando consolida√ß√£o...');
        // TODO: Implementar valida√ß√£o
    }

    async rollback() {
        console.log('üîÑ Executando rollback...');
        // TODO: Implementar rollback
    }
}

module.exports = AutoConsolidator;
        `.trim();

        await fs.writeFile(
            path.join(this.baseDir, 'enterprise-auto-consolidator.js'),
            consolidatorCode
        );

        console.log('  ‚úÖ Consolidador autom√°tico gerado');
    }

    async generateReport() {
        console.log('\nüìä Gerando relat√≥rio...');
        
        const report = {
            timestamp: new Date().toISOString(),
            analysis: this.duplications,
            consolidationPlan: this.consolidationPlan,
            summary: {
                totalDuplications: this.calculateTotalDuplications(),
                consolidationOpportunities: this.calculateOpportunities(),
                estimatedBenefits: this.consolidationPlan.benefits,
                recommendedAction: this.getRecommendedAction()
            }
        };

        await fs.writeFile(
            'docs/reports/enterprise-consolidation-analysis.json',
            JSON.stringify(report, null, 2)
        );

        console.log('üìÑ Relat√≥rio salvo em: docs/reports/enterprise-consolidation-analysis.json');
        
        // Exibir resumo
        this.displaySummary(report.summary);
    }

    // =============================================
    // M√âTODOS AUXILIARES
    // =============================================

    extractEndpoints(content) {
        const endpoints = [];
        const routePatterns = [
            /app\.(get|post|put|delete)\s*\(\s*['"`]([^'"`]+)['"`]/g,
            /router\.(get|post|put|delete)\s*\(\s*['"`]([^'"`]+)['"`]/g
        ];

        routePatterns.forEach(pattern => {
            let match;
            while ((match = pattern.exec(content)) !== null) {
                endpoints.push({
                    method: match[1].toUpperCase(),
                    path: match[2]
                });
            }
        });

        return endpoints;
    }

    extractClasses(content) {
        const classes = [];
        const classPattern = /class\s+(\w+)/g;
        let match;
        
        while ((match = classPattern.exec(content)) !== null) {
            classes.push(match[1]);
        }
        
        return classes;
    }

    extractMethods(content) {
        const methods = [];
        const methodPatterns = [
            /async\s+(\w+)\s*\(/g,
            /(\w+)\s*\(\s*[^)]*\)\s*\{/g
        ];

        methodPatterns.forEach(pattern => {
            let match;
            while ((match = pattern.exec(content)) !== null) {
                if (match[1] && !['if', 'for', 'while', 'switch'].includes(match[1])) {
                    methods.push(match[1]);
                }
            }
        });

        return [...new Set(methods)]; // Remove duplicatas
    }

    extractReactHooks(content) {
        const hooks = [];
        const hookPattern = /use(\w+)/g;
        let match;
        
        while ((match = hookPattern.exec(content)) !== null) {
            hooks.push('use' + match[1]);
        }
        
        return [...new Set(hooks)];
    }

    extractReactProps(content) {
        const propsPattern = /const\s+\{([^}]+)\}\s*=\s*props/;
        const match = content.match(propsPattern);
        
        if (match) {
            return match[1].split(',').map(prop => prop.trim());
        }
        
        return [];
    }

    identifyServiceType(content) {
        if (content.includes('stripe') || content.includes('Stripe')) return 'stripe';
        if (content.includes('payment') || content.includes('Payment')) return 'payment';
        if (content.includes('affiliate') || content.includes('Affiliate')) return 'affiliate';
        return 'unknown';
    }

    findDuplicatedEndpoints(apiFiles) {
        const allEndpoints = [];
        const duplicated = [];

        apiFiles.forEach(file => {
            file.endpoints.forEach(endpoint => {
                const existing = allEndpoints.find(e => 
                    e.method === endpoint.method && e.path === endpoint.path
                );
                
                if (existing) {
                    duplicated.push({
                        endpoint: `${endpoint.method} ${endpoint.path}`,
                        files: [existing.source, file.file]
                    });
                } else {
                    allEndpoints.push({
                        ...endpoint,
                        source: file.file
                    });
                }
            });
        });

        return duplicated;
    }

    findDuplicatedComponents(components) {
        const duplicated = [];
        const nameGroups = {};

        components.forEach(comp => {
            if (!nameGroups[comp.name]) {
                nameGroups[comp.name] = [];
            }
            nameGroups[comp.name].push(comp);
        });

        Object.keys(nameGroups).forEach(name => {
            if (nameGroups[name].length > 1) {
                duplicated.push({
                    name,
                    files: nameGroups[name].map(c => c.file)
                });
            }
        });

        return duplicated;
    }

    findDuplicatedLogic(content) {
        // Implementa√ß√£o simplificada para detectar l√≥gica duplicada
        const duplicatedPatterns = [
            'stripe.paymentIntents.create',
            'affiliate_code',
            'commission',
            'Pool',
            'async.*await.*query'
        ];

        return duplicatedPatterns.filter(pattern => 
            new RegExp(pattern, 'i').test(content)
        );
    }

    calculateTotalDuplications() {
        const apiDups = this.duplications.apis.duplicatedEndpoints?.length || 0;
        const serviceDups = this.duplications.services.stripeImplementations || 0;
        const componentDups = this.duplications.components.duplicatedComponents?.length || 0;
        
        return apiDups + serviceDups + componentDups;
    }

    calculateOpportunities() {
        let opportunities = 0;
        
        if (this.duplications.apis.consolidationOpportunity) opportunities++;
        if (this.duplications.services.consolidationOpportunity) opportunities++;
        if (this.duplications.components.consolidationOpportunity) opportunities++;
        if (this.duplications.configs.consolidationOpportunity) opportunities++;
        
        return opportunities;
    }

    getRecommendedAction() {
        const totalDups = this.calculateTotalDuplications();
        
        if (totalDups > 5) return 'CONSOLIDA√á√ÉO URGENTE RECOMENDADA';
        if (totalDups > 2) return 'CONSOLIDA√á√ÉO RECOMENDADA';
        return 'ESTRUTURA ACEIT√ÅVEL';
    }

    displaySummary(summary) {
        console.log('\nüìä RESUMO DA AN√ÅLISE:');
        console.log(`   Total de duplica√ß√µes: ${summary.totalDuplications}`);
        console.log(`   Oportunidades de consolida√ß√£o: ${summary.consolidationOpportunities}`);
        console.log(`   A√ß√£o recomendada: ${summary.recommendedAction}`);
        console.log(`\nüí° BENEF√çCIOS ESTIMADOS:`);
        summary.estimatedBenefits.forEach(benefit => {
            console.log(`   ‚Ä¢ ${benefit}`);
        });
    }
}

// Executar an√°lise se chamado diretamente
if (require.main === module) {
    const consolidator = new EnterpriseConsolidator();
    consolidator.analyzeAndConsolidate()
        .then(plan => {
            console.log('\nüéâ AN√ÅLISE DE CONSOLIDA√á√ÉO CONCLU√çDA!');
            console.log(`\nüìã PR√ìXIMO PASSO: Revisar plano e executar consolida√ß√£o`);
            process.exit(0);
        })
        .catch(error => {
            console.error('\nüí• AN√ÅLISE FALHOU:', error.message);
            process.exit(1);
        });
}

module.exports = EnterpriseConsolidator;
