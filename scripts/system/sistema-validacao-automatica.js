#!/usr/bin/env node

/**
 * üöÄ SISTEMA DE VALIDA√á√ÉO AUTOM√ÅTICA - ESPECIALISTA
 * =================================================
 * 
 * Sistema completo que valida automaticamente todas as contas
 * e garante que os executores se conectem corretamente
 * 
 * FUNCIONALIDADES:
 * - Valida√ß√£o autom√°tica de todas as chaves
 * - Atualiza√ß√£o de status no banco
 * - Inicializa√ß√£o do sistema de trading
 * - Monitoramento cont√≠nuo
 * - Reconex√£o autom√°tica
 */

const { Pool } = require('pg');
const ccxt = require('ccxt');
const axios = require('axios');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');

// Configura√ß√£o do banco
const pool = new Pool({
    connectionString: process.env.DATABASE_URL || 'process.env.DATABASE_URL',
    ssl: { rejectUnauthorized: false }
});

class SistemaValidacaoAutomatica {
    constructor() {
        this.currentIP = null;
        this.ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || 'coinbitclub2024_secret_key_for_encryption';
        this.ALGORITHM = 'aes-256-cbc';
        
        // Cache de conex√µes validadas
        this.validatedConnections = new Map();
        this.connectionInstances = new Map();
        
        // Configura√ß√µes de valida√ß√£o
        this.validationConfig = {
            intervalValidation: 5 * 60 * 1000, // 5 minutos
            retryAttempts: 3,
            timeoutSeconds: 30,
            healthCheckInterval: 60 * 1000 // 1 minuto
        };

        // Estat√≠sticas do sistema
        this.systemStats = {
            totalKeys: 0,
            validatedKeys: 0,
            failedKeys: 0,
            activeConnections: 0,
            lastValidation: null,
            uptime: Date.now()
        };

        console.log('üöÄ SISTEMA DE VALIDA√á√ÉO AUTOM√ÅTICA INICIALIZADO');
    }

    /**
     * üîê SISTEMA DE CRIPTOGRAFIA
     */
    decrypt(encryptedText) {
        try {
            if (!encryptedText || typeof encryptedText !== 'string') {
                return null;
            }

            if (!encryptedText.includes(':')) {
                return encryptedText; // N√£o criptografado
            }

            const [ivHex, encrypted] = encryptedText.split(':');
            if (!ivHex || !encrypted) {
                return null;
            }

            const decipher = crypto.createDecipher(this.ALGORITHM, this.ENCRYPTION_KEY);
            let decrypted = decipher.update(encrypted, 'hex', 'utf8');
            decrypted += decipher.final('utf8');
            
            return decrypted;
        } catch (error) {
            console.error(`‚ùå Erro na descriptografia: ${error.message}`);
            return null;
        }
    }

    /**
     * üåê DETEC√á√ÉO DE IP AUTOM√ÅTICA
     */
    async detectarIPAutomatico() {
        const ipServices = [
            'https://api.ipify.org?format=json',
            'https://ipapi.co/ip/',
            'https://icanhazip.com',
            'https://ifconfig.me/ip'
        ];

        for (const service of ipServices) {
            try {
                const response = await axios.get(service, { timeout: 5000 });
                const ip = typeof response.data === 'string' 
                    ? response.data.trim() 
                    : response.data.ip;
                
                this.currentIP = ip;
                return this.currentIP;
            } catch (error) {
                continue;
            }
        }
        
        throw new Error('N√£o foi poss√≠vel detectar IP');
    }

    /**
     * üîë BUSCAR TODAS AS CHAVES PARA VALIDA√á√ÉO
     */
    async buscarTodasChaves() {
        console.log('üîç INICIANDO BUSCA DE CHAVES...');
        
        try {
            // 1. Primeiro verificar se existem usu√°rios e chaves
            const usuariosCount = await pool.query('SELECT COUNT(*) as count FROM users');
            const chavesCount = await pool.query('SELECT COUNT(*) as count FROM user_api_keys');
            
            console.log(`üìä Total no banco: ${usuariosCount.rows[0].count} usu√°rios, ${chavesCount.rows[0].count} chaves`);
            
            // 2. Se n√£o houver dados, criar dados de teste com a chave da Erica
            if (parseInt(usuariosCount.rows[0].count) === 0) {
                console.log('üîß CRIANDO DADOS DE TESTE - Usu√°rio Erica...');
                
                // Criar usu√°rio Erica
                const ericaUser = await pool.query(`
                    INSERT INTO users (username, email, is_active) 
                    VALUES ('erica', 'erica@coinbitclub.com', true) 
                    RETURNING id
                `);
                
                const ericaId = ericaUser.rows[0].id;
                console.log(`‚úÖ Usu√°rio Erica criado (ID: ${ericaId})`);
                
                // Criar chave API da Erica (baseado no seu teste anterior)
                await pool.query(`
                    INSERT INTO user_api_keys (user_id, exchange, environment, api_key, secret_key, is_active) 
                    VALUES ($1, 'bybit', 'mainnet', '2iNeNZQepHJS0lWBkf', 'ZtmCtREm6CU8CKW68Z', true)
                `, [ericaId]);
                
                console.log('‚úÖ Chave API da Erica adicionada (Bybit Mainnet)');
                
                // Adicionar mais usu√°rios de teste se necess√°rio
                const testUsers = [
                    { username: 'admin', email: 'admin@coinbitclub.com' },
                    { username: 'trader1', email: 'trader1@coinbitclub.com' },
                    { username: 'trader2', email: 'trader2@coinbitclub.com' }
                ];
                
                for (const user of testUsers) {
                    const newUser = await pool.query(`
                        INSERT INTO users (username, email, is_active) 
                        VALUES ($1, $2, true) 
                        RETURNING id
                    `, [user.username, user.email]);
                    
                    console.log(`‚úÖ Usu√°rio ${user.username} criado (ID: ${newUser.rows[0].id})`);
                }
            }
            
            // 3. Verificar usu√°rios ativos
            const usuariosAtivos = await pool.query('SELECT COUNT(*) as count FROM users WHERE is_active = true');
            console.log(`üë• Usu√°rios ativos: ${usuariosAtivos.rows[0].count}`);
            
            // 4. Verificar chaves ativas
            const chavesAtivas = await pool.query('SELECT COUNT(*) as count FROM user_api_keys WHERE is_active = true');
            console.log(`üîë Chaves ativas: ${chavesAtivas.rows[0].count}`);
            
            // 5. Verificar chaves com dados
            const chavesComDados = await pool.query('SELECT COUNT(*) as count FROM user_api_keys WHERE api_key IS NOT NULL AND secret_key IS NOT NULL');
            console.log(`üìù Chaves com dados: ${chavesComDados.rows[0].count}`);
            
            // 6. CORRE√á√ÉO AUTOM√ÅTICA: Ativar usu√°rios e chaves se necess√°rio
            if (parseInt(usuariosAtivos.rows[0].count) === 0) {
                console.log('üîß CORRE√á√ÉO: Ativando usu√°rios inativos...');
                await pool.query('UPDATE users SET is_active = true WHERE is_active = false');
                console.log('‚úÖ Usu√°rios ativados');
            }
            
            if (parseInt(chavesAtivas.rows[0].count) === 0 && parseInt(chavesComDados.rows[0].count) > 0) {
                console.log('üîß CORRE√á√ÉO: Ativando chaves com dados...');
                await pool.query('UPDATE user_api_keys SET is_active = true WHERE is_active = false AND api_key IS NOT NULL AND secret_key IS NOT NULL');
                console.log('‚úÖ Chaves ativadas');
            }
            
            // 7. Query principal
            const query = `
                SELECT 
                    u.id as user_id,
                    u.username,
                    u.email,
                    uak.id as key_id,
                    uak.exchange,
                    uak.environment,
                    uak.api_key,
                    uak.secret_key,
                    uak.validation_status,
                    uak.last_validated_at,
                    uak.is_active
                FROM users u
                JOIN user_api_keys uak ON u.id = uak.user_id
                WHERE u.is_active = true 
                AND uak.is_active = true
                AND uak.api_key IS NOT NULL
                AND uak.secret_key IS NOT NULL
                ORDER BY u.id, uak.exchange, uak.environment
            `;

            const result = await pool.query(query);
            this.systemStats.totalKeys = result.rows.length;
            
            console.log(`üîë RESULTADO FINAL: Encontradas ${result.rows.length} chaves para valida√ß√£o`);
            
            if (result.rows.length > 0) {
                console.log('üìã CHAVES ENCONTRADAS:');
                result.rows.forEach(c => {
                    console.log(`   üîë ${c.username} - ${c.exchange} ${c.environment} (ID: ${c.key_id})`);
                });
            } else {
                console.log('‚ùå PROBLEMA PERSISTENTE: Nenhuma chave encontrada ap√≥s corre√ß√µes');
            }
            
            return result.rows;
            
        } catch (error) {
            console.error('‚ùå Erro na busca de chaves:', error.message);
            console.error('Stack:', error.stack);
            return [];
        }
    }

    /**
     * ‚úÖ VALIDAR CHAVE INDIVIDUAL
     */
    async validarChaveIndividual(chave) {
        const keyId = `${chave.user_id}_${chave.exchange}_${chave.environment}`;
        
        try {
            // Descriptografar chaves
            const apiKey = this.decrypt(chave.api_key);
            const secretKey = this.decrypt(chave.secret_key);

            if (!apiKey || !secretKey) {
                throw new Error('Falha na descriptografia');
            }

            let validationResult;

            if (chave.exchange === 'bybit') {
                validationResult = await this.validarBybit(apiKey, secretKey, chave.environment);
            } else if (chave.exchange === 'binance') {
                validationResult = await this.validarBinance(apiKey, secretKey, chave.environment);
            } else {
                throw new Error(`Exchange ${chave.exchange} n√£o suportada`);
            }

            // Atualizar status no banco
            await this.atualizarStatusChave(chave.key_id, validationResult);

            // Cache da conex√£o validada
            if (validationResult.success) {
                this.validatedConnections.set(keyId, {
                    ...chave,
                    apiKey,
                    secretKey,
                    lastValidated: new Date(),
                    balance: validationResult.balance
                });

                // Criar inst√¢ncia CCXT
                const instance = await this.criarInstanciaCCXT(chave.exchange, chave.environment, apiKey, secretKey);
                if (instance) {
                    this.connectionInstances.set(keyId, instance);
                }

                this.systemStats.validatedKeys++;
                this.systemStats.activeConnections = this.connectionInstances.size;
            } else {
                this.systemStats.failedKeys++;
            }

            return validationResult;

        } catch (error) {
            console.error(`‚ùå Erro ao validar chave ${keyId}: ${error.message}`);
            
            // Atualizar como falha no banco
            await this.atualizarStatusChave(chave.key_id, {
                success: false,
                error: error.message,
                timestamp: new Date()
            });

            this.systemStats.failedKeys++;
            return { success: false, error: error.message };
        }
    }

    /**
     * üîç VALIDAR BYBIT
     */
    async validarBybit(apiKey, secretKey, environment) {
        const baseURL = environment === 'testnet' 
            ? 'https://api-testnet.bybit.com' 
            : 'https://api.bybit.com';

        try {
            const timestamp = Date.now().toString();
            const recvWindow = '5000';
            const params = { accountType: 'UNIFIED' };
            const queryString = new URLSearchParams(params).toString();
            
            const signPayload = timestamp + apiKey + recvWindow + queryString;
            const signature = crypto.createHmac('sha256', secretKey).update(signPayload).digest('hex');
            
            const headers = {
                'X-BAPI-API-KEY': apiKey,
                'X-BAPI-SIGN': signature,
                'X-BAPI-SIGN-TYPE': '2',
                'X-BAPI-TIMESTAMP': timestamp,
                'X-BAPI-RECV-WINDOW': recvWindow,
                'Content-Type': 'application/json'
            };

            const response = await axios.get(`${baseURL}/v5/account/wallet-balance?${queryString}`, {
                headers,
                timeout: this.validationConfig.timeoutSeconds * 1000
            });

            if (response.data.retCode === 0) {
                const balance = this.extrairSaldoBybit(response.data);
                return {
                    success: true,
                    balance,
                    timestamp: new Date(),
                    response_code: response.data.retCode
                };
            } else {
                return {
                    success: false,
                    error: `${response.data.retCode}: ${response.data.retMsg}`,
                    timestamp: new Date()
                };
            }

        } catch (error) {
            return {
                success: false,
                error: error.message,
                timestamp: new Date()
            };
        }
    }

    /**
     * üîç VALIDAR BINANCE
     */
    async validarBinance(apiKey, secretKey, environment) {
        try {
            const exchange = new ccxt.binance({
                apiKey: apiKey,
                secret: secretKey,
                sandbox: environment === 'testnet',
                enableRateLimit: true,
                timeout: this.validationConfig.timeoutSeconds * 1000
            });

            // Testar conectividade
            await exchange.loadMarkets();
            const balance = await exchange.fetchBalance();
            
            return {
                success: true,
                balance: {
                    USDT: balance.USDT?.total || 0,
                    totalUSD: balance.USDT?.total || 0
                },
                timestamp: new Date()
            };

        } catch (error) {
            return {
                success: false,
                error: error.message,
                timestamp: new Date()
            };
        }
    }

    /**
     * üìä EXTRAIR SALDO BYBIT
     */
    extrairSaldoBybit(data) {
        try {
            const coins = data.result?.list?.[0]?.coin || [];
            let usdtBalance = 0;
            let totalUSD = 0;

            coins.forEach(coin => {
                if (coin.coin === 'USDT') {
                    usdtBalance = parseFloat(coin.walletBalance) || 0;
                }
                totalUSD += parseFloat(coin.usdValue) || 0;
            });

            return {
                USDT: usdtBalance,
                totalUSD: totalUSD.toFixed(2),
                coinCount: coins.length
            };
        } catch (error) {
            return { USDT: 0, totalUSD: '0.00', coinCount: 0 };
        }
    }

    /**
     * üè≠ CRIAR INST√ÇNCIA CCXT
     */
    async criarInstanciaCCXT(exchange, environment, apiKey, secretKey) {
        try {
            if (exchange === 'bybit') {
                return new ccxt.bybit({
                    apiKey: apiKey,
                    secret: secretKey,
                    sandbox: environment === 'testnet',
                    enableRateLimit: true,
                    options: { defaultType: 'linear' }
                });
            } else if (exchange === 'binance') {
                return new ccxt.binance({
                    apiKey: apiKey,
                    secret: secretKey,
                    sandbox: environment === 'testnet',
                    enableRateLimit: true,
                    options: { defaultType: 'future' }
                });
            }
        } catch (error) {
            console.error(`‚ùå Erro ao criar inst√¢ncia ${exchange}: ${error.message}`);
            return null;
        }
    }

    /**
     * üíæ ATUALIZAR STATUS NO BANCO
     */
    async atualizarStatusChave(keyId, result) {
        try {
            const status = result.success ? 'CONNECTED' : 'FAILED';
            const errorDetails = result.success ? null : JSON.stringify({
                error: result.error,
                timestamp: result.timestamp
            });

            await pool.query(`
                UPDATE user_api_keys 
                SET 
                    validation_status = $1,
                    last_validated_at = $2,
                    error_details = $3,
                    updated_at = $4
                WHERE id = $5
            `, [
                status,
                new Date(),
                errorDetails,
                new Date(),
                keyId
            ]);

        } catch (error) {
            console.error(`‚ùå Erro ao atualizar status da chave ${keyId}: ${error.message}`);
        }
    }

    /**
     * üîÑ VALIDA√á√ÉO COMPLETA DO SISTEMA
     */
    async executarValidacaoCompleta() {
        console.log('\nüîÑ INICIANDO VALIDA√á√ÉO COMPLETA DO SISTEMA');
        console.log('==========================================');
        
        try {
            // Reset das estat√≠sticas
            this.systemStats.validatedKeys = 0;
            this.systemStats.failedKeys = 0;
            this.systemStats.lastValidation = new Date();

            // Detectar IP
            await this.detectarIPAutomatico();
            console.log(`üåê IP detectado: ${this.currentIP}`);

            // Buscar todas as chaves
            const chaves = await this.buscarTodasChaves();

            if (chaves.length === 0) {
                console.log('‚ö†Ô∏è Nenhuma chave encontrada para valida√ß√£o');
                return false;
            }

            // Validar cada chave
            console.log(`üîç Validando ${chaves.length} chaves...`);
            
            const validationPromises = chaves.map(async (chave) => {
                for (let attempt = 1; attempt <= this.validationConfig.retryAttempts; attempt++) {
                    const result = await this.validarChaveIndividual(chave);
                    
                    if (result.success) {
                        console.log(`‚úÖ ${chave.username} - ${chave.exchange} ${chave.environment}: CONECTADO`);
                        return { chave, result, success: true };
                    } else if (attempt === this.validationConfig.retryAttempts) {
                        console.log(`‚ùå ${chave.username} - ${chave.exchange} ${chave.environment}: FALHA (${result.error})`);
                        return { chave, result, success: false };
                    } else {
                        console.log(`‚ö†Ô∏è Tentativa ${attempt}/${this.validationConfig.retryAttempts} falhou para ${chave.username} - ${chave.exchange}`);
                        await new Promise(resolve => setTimeout(resolve, 2000)); // Wait before retry
                    }
                }
            });

            await Promise.all(validationPromises);

            // Relat√≥rio final
            this.gerarRelatorioValidacao();
            
            // Salvar estado do sistema
            await this.salvarEstadoSistema();

            return this.systemStats.validatedKeys > 0;

        } catch (error) {
            console.error('‚ùå Erro na valida√ß√£o completa:', error.message);
            return false;
        }
    }

    /**
     * üìã GERAR RELAT√ìRIO DE VALIDA√á√ÉO
     */
    gerarRelatorioValidacao() {
        console.log('\nüìä RELAT√ìRIO DE VALIDA√á√ÉO');
        console.log('========================');
        console.log(`üïê Timestamp: ${this.systemStats.lastValidation?.toISOString()}`);
        console.log(`üåê IP: ${this.currentIP}`);
        console.log(`üîë Total de chaves: ${this.systemStats.totalKeys}`);
        console.log(`‚úÖ Chaves validadas: ${this.systemStats.validatedKeys}`);
        console.log(`‚ùå Chaves com falha: ${this.systemStats.failedKeys}`);
        console.log(`üîó Conex√µes ativas: ${this.systemStats.activeConnections}`);
        console.log(`üìà Taxa de sucesso: ${((this.systemStats.validatedKeys / this.systemStats.totalKeys) * 100).toFixed(1)}%`);

        const status = this.systemStats.validatedKeys > 0 ? 'üü¢ OPERACIONAL' : 'üî¥ CR√çTICO';
        console.log(`üìä Status do sistema: ${status}`);

        // Detalhes das conex√µes validadas
        if (this.validatedConnections.size > 0) {
            console.log('\n‚úÖ CONEX√ïES VALIDADAS:');
            for (const [keyId, connection] of this.validatedConnections) {
                console.log(`   ${connection.username} - ${connection.exchange} ${connection.environment}: $${connection.balance?.totalUSD || '0.00'}`);
            }
        }
    }

    /**
     * üíæ SALVAR ESTADO DO SISTEMA
     */
    async salvarEstadoSistema() {
        try {
            const estado = {
                timestamp: new Date().toISOString(),
                stats: this.systemStats,
                ip: this.currentIP,
                validatedConnections: Array.from(this.validatedConnections.keys()),
                activeInstances: Array.from(this.connectionInstances.keys())
            };

            const filePath = path.join(__dirname, 'system-state.json');
            fs.writeFileSync(filePath, JSON.stringify(estado, null, 2));
            console.log(`üíæ Estado do sistema salvo em: ${filePath}`);

        } catch (error) {
            console.error('‚ùå Erro ao salvar estado do sistema:', error.message);
        }
    }

    /**
     * üîÑ MONITORAMENTO CONT√çNUO
     */
    async iniciarMonitoramentoContinuo() {
        console.log('üîÑ INICIANDO MONITORAMENTO CONT√çNUO');
        
        // Valida√ß√£o inicial
        await this.executarValidacaoCompleta();

        // Monitoramento de sa√∫de das conex√µes
        setInterval(async () => {
            console.log('‚ù§Ô∏è Health check das conex√µes...');
            await this.verificarSaudeConexoes();
        }, this.validationConfig.healthCheckInterval);

        // Revalida√ß√£o peri√≥dica
        setInterval(async () => {
            console.log('üîÑ Revalida√ß√£o peri√≥dica...');
            await this.executarValidacaoCompleta();
        }, this.validationConfig.intervalValidation);

        console.log('‚úÖ Monitoramento cont√≠nuo ativo');
    }

    /**
     * ‚ù§Ô∏è VERIFICAR SA√öDE DAS CONEX√ïES
     */
    async verificarSaudeConexoes() {
        for (const [keyId, instance] of this.connectionInstances) {
            try {
                // Teste simples de conectividade
                await instance.fetchTicker('BTC/USDT');
                // Se chegou aqui, a conex√£o est√° OK
            } catch (error) {
                console.warn(`‚ö†Ô∏è Conex√£o ${keyId} com problemas: ${error.message}`);
                
                // Remover da cache e tentar revalidar
                this.connectionInstances.delete(keyId);
                const connection = this.validatedConnections.get(keyId);
                
                if (connection) {
                    console.log(`üîÑ Tentando reconectar ${keyId}...`);
                    await this.validarChaveIndividual(connection);
                }
            }
        }
    }

    /**
     * üéØ OBTER CONEX√ÉO VALIDADA
     */
    getValidatedConnection(userId, exchange, environment) {
        const keyId = `${userId}_${exchange}_${environment}`;
        return this.connectionInstances.get(keyId);
    }

    /**
     * üìä OBTER ESTAT√çSTICAS DO SISTEMA
     */
    getSystemStats() {
        return {
            ...this.systemStats,
            uptime: Date.now() - this.systemStats.uptime,
            currentIP: this.currentIP,
            validatedConnectionsCount: this.validatedConnections.size,
            activeInstancesCount: this.connectionInstances.size
        };
    }

    /**
     * üöÄ INICIALIZA√á√ÉO COMPLETA DO SISTEMA
     */
    async inicializarSistemaCompleto() {
        console.log('\nüöÄ INICIALIZA√á√ÉO COMPLETA DO SISTEMA COINBITCLUB');
        console.log('================================================');
        
        try {
            // 1. Valida√ß√£o completa
            const success = await this.executarValidacaoCompleta();
            
            if (!success) {
                console.error('‚ùå Falha na valida√ß√£o inicial - sistema n√£o pode iniciar');
                process.exit(1);
            }

            // 2. Iniciar monitoramento
            await this.iniciarMonitoramentoContinuo();

            // 3. Registrar handlers de sinal
            process.on('SIGINT', async () => {
                console.log('\nüõë Recebido sinal de parada...');
                await this.pararSistema();
                process.exit(0);
            });

            console.log('\nüéâ SISTEMA COINBITCLUB TOTALMENTE OPERACIONAL');
            console.log('============================================');
            console.log(`‚úÖ ${this.systemStats.validatedKeys} contas validadas`);
            console.log(`üîó ${this.systemStats.activeConnections} conex√µes ativas`);
            console.log(`üåê IP: ${this.currentIP}`);
            console.log('üîÑ Monitoramento cont√≠nuo ativo');
            
            return true;

        } catch (error) {
            console.error('‚ùå Erro na inicializa√ß√£o do sistema:', error.message);
            return false;
        }
    }

    /**
     * üõë PARAR SISTEMA
     */
    async pararSistema() {
        console.log('üõë Parando sistema...');
        
        try {
            // Salvar estado final
            await this.salvarEstadoSistema();
            
            // Fechar conex√µes
            await pool.end();
            
            console.log('‚úÖ Sistema parado com seguran√ßa');
        } catch (error) {
            console.error('‚ùå Erro ao parar sistema:', error.message);
        }
    }
}

// Exportar para uso em outros m√≥dulos
module.exports = SistemaValidacaoAutomatica;

// Executar se chamado diretamente
if (require.main === module) {
    const sistema = new SistemaValidacaoAutomatica();
    sistema.inicializarSistemaCompleto();
}
