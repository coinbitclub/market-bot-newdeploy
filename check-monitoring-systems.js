#!/usr/bin/env node

/**
 * üîç VERIFICA√á√ÉO R√ÅPIDA DOS SISTEMAS DE MONITORAMENTO
 * Verifica se os sistemas est√£o integrados e funcionando
 */

const axios = require('axios');

class SystemChecker {
    constructor() {
        this.baseUrl = 'https://coinbitclub-market-bot-backend-production.up.railway.app';
        this.results = {
            app_health: null,
            monitoring_tests: {},
            api_endpoints: {},
            integration_status: null
        };
    }

    async checkAppHealth() {
        console.log('üè• Verificando sa√∫de da aplica√ß√£o...');
        
        try {
            const response = await axios.get(`${this.baseUrl}/health`, { timeout: 10000 });
            this.results.app_health = {
                status: 'healthy',
                response: response.data
            };
            console.log('‚úÖ Aplica√ß√£o est√° online e saud√°vel');
            return true;
        } catch (error) {
            this.results.app_health = {
                status: 'error',
                error: error.message
            };
            console.log('‚ùå Aplica√ß√£o offline ou com problemas');
            return false;
        }
    }

    async checkTestEndpoints() {
        console.log('\nüß™ Verificando endpoints de teste...');
        
        const testEndpoints = [
            {
                name: 'available_tests',
                path: '/api/test/available-tests',
                method: 'GET'
            },
            {
                name: 'api_key_error_test',
                path: '/api/test/api-key-error',
                method: 'POST',
                body: {
                    userId: 999,
                    apiKey: 'test_invalid_key',
                    exchange: 'bybit'
                }
            },
            {
                name: 'database_constraint_test',
                path: '/api/test/database-constraint-error',
                method: 'POST',
                body: {
                    errorType: 'duplicate_key',
                    userId: 999
                }
            }
        ];

        for (const endpoint of testEndpoints) {
            try {
                console.log(`üîç Testando ${endpoint.name}...`);
                
                const config = {
                    method: endpoint.method,
                    url: `${this.baseUrl}${endpoint.path}`,
                    timeout: 15000,
                    headers: { 'Content-Type': 'application/json' }
                };

                if (endpoint.body) {
                    config.data = endpoint.body;
                }

                const response = await axios(config);
                
                this.results.monitoring_tests[endpoint.name] = {
                    status: 'success',
                    statusCode: response.status,
                    response: response.data
                };
                
                console.log(`   ‚úÖ ${endpoint.name}: OK`);

            } catch (error) {
                this.results.monitoring_tests[endpoint.name] = {
                    status: 'error',
                    statusCode: error.response?.status || 'timeout',
                    error: error.response?.data || error.message
                };
                
                console.log(`   ‚ùå ${endpoint.name}: ${error.response?.status || 'ERROR'}`);
            }
        }
    }

    async checkMonitoringEndpoints() {
        console.log('\nüìä Verificando endpoints de monitoramento...');
        
        const monitoringEndpoints = [
            {
                name: 'monitoring_stats',
                path: '/api/monitoring/stats'
            },
            {
                name: 'monitoring_dashboard',
                path: '/api/monitoring/dashboard'
            },
            {
                name: 'systems_status',
                path: '/api/systems/status'
            },
            {
                name: 'ip_diagnostic',
                path: '/api/ip-diagnostic'
            }
        ];

        for (const endpoint of monitoringEndpoints) {
            try {
                console.log(`üîç Testando ${endpoint.name}...`);
                
                const response = await axios.get(`${this.baseUrl}${endpoint.path}`, { 
                    timeout: 10000 
                });
                
                this.results.api_endpoints[endpoint.name] = {
                    status: 'available',
                    statusCode: response.status,
                    hasData: !!response.data
                };
                
                console.log(`   ‚úÖ ${endpoint.name}: Dispon√≠vel`);

            } catch (error) {
                this.results.api_endpoints[endpoint.name] = {
                    status: 'error',
                    statusCode: error.response?.status || 'timeout',
                    error: error.message
                };
                
                console.log(`   ‚ùå ${endpoint.name}: ${error.response?.status || 'ERROR'}`);
            }
        }
    }

    async generateReport() {
        console.log('\nüìã RELAT√ìRIO DE VERIFICA√á√ÉO DOS SISTEMAS');
        console.log('='.repeat(60));

        // 1. Status geral
        const appHealthy = this.results.app_health?.status === 'healthy';
        const testsWorking = Object.values(this.results.monitoring_tests)
            .some(test => test.status === 'success');
        const endpointsWorking = Object.values(this.results.api_endpoints)
            .some(endpoint => endpoint.status === 'available');

        console.log(`\nüéØ STATUS GERAL:`);
        console.log(`   üè• Aplica√ß√£o: ${appHealthy ? '‚úÖ Online' : '‚ùå Offline'}`);
        console.log(`   üß™ Testes: ${testsWorking ? '‚úÖ Funcionando' : '‚ùå Problemas'}`);
        console.log(`   üìä Monitoramento: ${endpointsWorking ? '‚úÖ Ativo' : '‚ùå Inativo'}`);

        // 2. Detalhes dos testes
        console.log(`\nüß™ TESTES DE ERRO:`);
        Object.entries(this.results.monitoring_tests).forEach(([name, result]) => {
            const icon = result.status === 'success' ? '‚úÖ' : '‚ùå';
            console.log(`   ${icon} ${name}: ${result.statusCode}`);
            
            if (result.status === 'success' && result.response) {
                if (result.response.test) {
                    console.log(`      üìù Teste: ${result.response.test}`);
                }
                if (result.response.message) {
                    console.log(`      üí¨ Mensagem: ${result.response.message}`);
                }
            }
        });

        // 3. Endpoints de monitoramento
        console.log(`\nüìä ENDPOINTS DE MONITORAMENTO:`);
        Object.entries(this.results.api_endpoints).forEach(([name, result]) => {
            const icon = result.status === 'available' ? '‚úÖ' : '‚ùå';
            console.log(`   ${icon} ${name}: ${result.statusCode}`);
        });

        // 4. Resumo de integra√ß√£o
        const successfulTests = Object.values(this.results.monitoring_tests)
            .filter(test => test.status === 'success').length;
        const availableEndpoints = Object.values(this.results.api_endpoints)
            .filter(endpoint => endpoint.status === 'available').length;

        console.log(`\nüéØ RESUMO DE INTEGRA√á√ÉO:`);
        console.log(`   üß™ Testes funcionais: ${successfulTests}/3`);
        console.log(`   üìä Endpoints ativos: ${availableEndpoints}/4`);
        
        if (appHealthy && successfulTests > 0 && availableEndpoints > 0) {
            console.log(`   üéâ SISTEMAS INTEGRADOS E FUNCIONAIS!`);
            this.results.integration_status = 'success';
        } else {
            console.log(`   ‚ö†Ô∏è  Alguns sistemas precisam de aten√ß√£o`);
            this.results.integration_status = 'partial';
        }

        // 5. Pr√≥ximos passos
        console.log(`\nüîß PR√ìXIMOS PASSOS RECOMENDADOS:`);
        
        if (!appHealthy) {
            console.log(`   1. ‚ö° Verificar deploy no Railway`);
            console.log(`   2. üìä Verificar logs de erro`);
        }
        
        if (successfulTests === 0) {
            console.log(`   1. üîç Verificar integra√ß√£o dos endpoints de teste`);
            console.log(`   2. üìä Verificar sistema de tratamento de erros`);
        }
        
        if (availableEndpoints === 0) {
            console.log(`   1. üîß Verificar inicializa√ß√£o do MonitoringIntegration`);
            console.log(`   2. üìä Verificar conex√£o com banco de dados`);
        }

        console.log(`\nüìû COMANDOS PARA TESTE MANUAL:`);
        console.log(`   curl ${this.baseUrl}/health`);
        console.log(`   curl ${this.baseUrl}/api/test/available-tests`);
        console.log(`   curl -X POST ${this.baseUrl}/api/test/api-key-error -H "Content-Type: application/json" -d '{"userId":999,"apiKey":"test","exchange":"bybit"}'`);

        return this.results;
    }

    async run() {
        console.log('üöÄ INICIANDO VERIFICA√á√ÉO DOS SISTEMAS DE MONITORAMENTO');
        console.log('='.repeat(60));
        
        try {
            // 1. Verificar sa√∫de da app
            const appHealthy = await this.checkAppHealth();
            
            if (appHealthy) {
                // 2. Verificar endpoints de teste
                await this.checkTestEndpoints();
                
                // 3. Verificar endpoints de monitoramento
                await this.checkMonitoringEndpoints();
            } else {
                console.log('‚ö†Ô∏è App offline - pulando testes de endpoints');
            }
            
            // 4. Gerar relat√≥rio final
            const results = await this.generateReport();
            
            console.log('\n‚úÖ Verifica√ß√£o conclu√≠da!');
            return results;
            
        } catch (error) {
            console.error('‚ùå Erro durante verifica√ß√£o:', error.message);
            throw error;
        }
    }
}

// Executar se chamado diretamente
if (require.main === module) {
    const checker = new SystemChecker();
    checker.run().catch(error => {
        console.error('üí• ERRO FATAL:', error.message);
        process.exit(1);
    });
}

module.exports = SystemChecker;
